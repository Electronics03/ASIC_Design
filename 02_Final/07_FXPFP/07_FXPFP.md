# 고정소수점(Fixed-Point, FXP) 표현

## 기본 개념 (Basic Concept)

* 고정소수점 표현(Fixed-point representation): 미리 정해진 소수부 길이를 사용하여 실수를 표현하는 방법이다.
* 정수 기반 산술 연산의 특성을 유지하면서 표현 범위를 확장한다.
* 사전에 정의된 소수점 위치를 통해 고정된 이진 포맷 내에서 소수 값을 표현할 수 있다.


## 포맷과 표기법 (Format and Notation)

* 포맷 표기법: S_a.b 형태로 작성하며,

  * a는 정수 비트 수
  * b는 소수 비트 수를 의미한다.
* 예시: S4.2 포맷

  * 1개의 부호 비트
  * 4개의 정수 비트
  * 2개의 소수 비트
* 전체 비트 폭 = 부호 비트 + 정수 비트 + 소수 비트
* 소수점 위치는 설계 시 고정되며 이후 변경되지 않는다.


## 수 표현 예시 (Number Representation Examples)

* 1.3 포맷: 정수 비트 1개, 소수 비트 3개
* 이진수 1.011:

  * $1 + 0 \times 2^{-1} + 1 \times 2^{-2} + 1 \times 2^{-3}$
  * $= 1 + 0.25 + 0.125 = 1.375$
* S4.2 포맷으로 4.23 표현

  * 00100.01 -> 반올림 결과 4.25
* S4.5 포맷으로 4.23 표현

  * 00100.00111 -> 반올림 결과 4.21875
* 대안 표기법:

  * 분수 형태 사용 (예: 1.375 = 11 / 8, 여기서 11은 정수 이진값, 8 = $2^3$)


## 10진수를 고정소수점 이진수로 변환 (Decimal -> Fixed-Point)

1. 10진수 값에 $2^f$를 곱한다 (f = 소수 비트 수)
2. 결과를 가장 가까운 정수로 반올림한다
3. 해당 정수를 이진수로 변환한다
4. 오른쪽에서 f비트 위치에 소수점을 둔다

### 예시: 1.389를 1.3 포맷으로 변환

* $1.389 \times 2^3 = 11.112$
* 반올림 -> 11
* 이진수 변환 -> 1.011
* 결과 값 = 1.375
* 오차 = 1.389 − 1.375 = 0.014


## 고정소수점 이진수를 10진수로 변환 (Fixed-Point -> Decimal)

* 방법 1: 정수로 변환 후 $1 / 2^f$를 곱한다
* 방법 2: 포맷을 인지한 상태에서 각 비트의 가중치를 합산한다


## 고정소수점에서의 부호 표현 (Sign Representation)

* 부호-크기(Sign magnitude) 또는 2의 보수(Two’s complement) 사용 가능
* 2의 보수 방식에서는 MSB가 음수 값을 의미한다
* 예시:

  * 소수 비트 3개인 포맷에서 11011
  * 계산: $-16 + 8 + 3 = -5$
  * 결과: $-5 / 2^3 = -5/8$


## 고정소수점 산술 연산 (Fixed-Point Arithmetic Operations)

### 덧셈 (Addition)

* 정수 이진 덧셈과 동일하게 수행한다
* 결과의 소수 비트 수는 유지된다
* 두 피연산자는 반드시 동일한 포맷으로 맞춰야 한다
* 소수 비트 수가 다르면 더 큰 쪽에 맞춰 정렬한다

예시

* 01.101 (2.3 포맷) + 101.01 (3.2 포맷)
* 둘 다 3.3 포맷으로 변환:

  * 001.101 + 101.010 = 110.111

수학적 원리:
$$
(x / 2^f) + (y / 2^f) = (x + y) / 2^f
$$


### 뺄셈 (Subtraction)

* 덧셈과 동일한 방식으로 수행한다
* 소수 비트 수를 유지한다
* 동일한 정렬 규칙을 따른다


### 곱셈 (Multiplication)

* 두 값을 정수로 간주하고 곱한다
* 결과의 소수 비트 수 = 입력 소수 비트 수의 합
* 예:

  * 4.6 × 4.6 -> 8.12 포맷
* 필요 시 다시 소수 비트를 줄여 반올림 가능

수학적 원리:
$$
(x / 2^{f_1}) \times (y / 2^{f_2}) = (x \times y) / 2^{(f_1 + f_2)}
$$


### 반올림 (Rounding)

* 소수 비트 수를 줄일 때 가장 가까운 값으로 반올림한다
* 예:

  * 0.10001000 (0.8 포맷) -> 0.1001 (0.4 포맷)
* 반올림은 양자화 오차를 줄인다


## 표현 오차와 정밀도 (Representation Error and Precision)

### 해상도 (Resolution)

* 표현 가능한 인접 숫자 간 최소 간격
* 소수 비트 수에 의해 결정됨
  $$
  Resolution = 2^{-f}
  $$
* 예:

  * 1.3 포맷 -> 해상도 = 0.125

> "이 포맷에서는 0.125, 0.25는 표현 가능하지만 0.2는 둘 중 하나로 근사해야 한다."


### 절대 오차 (Absolute Error)

* 실제 값과 표현된 값의 차이
* 예:

  * 4.23 -> S4.2 -> 4.25 -> 오차 0.02
  * 4.23 -> S4.5 -> 4.21875 -> 오차 0.01125


### 상대 오차 (Relative Error)

* 절대 오차 ÷ 실제 값
* 백분율로 표현
* 예:

  * S4.2: 약 0.47%
  * S4.5: 약 0.27%
* 소수 비트 수 증가 -> 상대 오차 감소


### 정확도와 정밀도 (Accuracy vs Precision)

* 정확도: 실제 값에 얼마나 가까운가
* 정밀도: 해상도로 결정되는 최소 구분 능력
* 정밀도가 높을수록 정확도도 향상된다
* 단점: 더 많은 하드웨어 자원 필요


## 작은 수에 대한 고려사항 (Small Numbers)

* 분모가 작으면 상대 오차가 급격히 커진다
* 절대 오차는 작아도 상대 오차는 클 수 있다
* 예:

  * 0.1을 0.1 오차로 표현 -> 상대 오차 100%
* 절대/상대 오차를 함께 고려해야 한다


# 부동소수점(Floating-Point, FP) 표현

## 개요 (Overview)

* 고정소수점보다 훨씬 넓은 표현 범위를 제공한다
* 매우 작은 수와 매우 큰 수를 동시에 표현할 수 있다
* 무한대, NaN 같은 특수 값 지원
* 하드웨어 구현이 복잡하다


## 이진 포맷 구조 (Binary Format)

* 구조: S E M

  * S: 부호 비트
  * E: 지수 비트 (bias 사용)
  * M: 가수(유효숫자)

값 계산식:
$$
(-1)^S \times (1 + \sum M_i 2^{-i}) \times 2^{(E - Bias)}
$$


## IEEE 754 표준

### 단정밀도 (32-bit)

* 1 sign, 8 exponent, 23 mantissa
* Bias = 127

### 배정밀도 (64-bit)

* 1 sign, 11 exponent, 52 mantissa
* Bias = 1023

### 반정밀도 (16-bit)

* 1 sign, 5 exponent, 10 mantissa
* Bias = 15


## 가수(Significand)

* 항상 정규화된 형태 (1.xxx)
* 맨 앞의 1은 저장하지 않는 hidden bit
* 범위: $1.0 \le |significand| < 2.0$


## 지수 표현 (Exponent Representation)

* Excess(bias) 방식 사용
* 저장 지수 = 실제 지수 + Bias
* 지수는 항상 unsigned 형태로 저장된다


## 특수 값 (Special Values)

### 무한대 (Infinity)

* Exponent = 모두 1, Mantissa = 0
* 연산 가능, 오버플로 체크 불필요

### NaN

* Exponent = 모두 1, Mantissa ≠ 0
* 정의되지 않은 연산 결과

### 0

* Exponent = 0, Mantissa = 0
* +0, −0 모두 존재

### 비정규 수 (Denormal)

* Exponent = 0, Mantissa ≠ 0
* 점진적 언더플로우 허용


## 고정소수점 vs 부동소수점 비교

| 항목      | Fixed-Point | Floating-Point |
|- |-- |-- |
| 표현 범위   | 좁음          | 매우 넓음          |
| 해상도     | 일정          | 상대적            |
| 사용성     | 어려움         | 쉬움             |
| 하드웨어 비용 | 낮음          | 높음             |
| 전력/면적   | 작음          | 큼              |


## 산술 논리 연산 장치 (ALU)

### 정의

* ALU: 산술 및 비트 연산을 수행하는 조합논리 회로
* CPU, GPU의 핵심 연산 유닛이다


### 기본 구조

* 두 입력 A, B
* Opcode(Selector)가 수행할 연산을 결정
* 여러 연산 결과 중 MUX로 선택

> Opcode의 역할은 어떤 연산의 결과를 출력할지 선택하는 것이다.


### 에너지 관점

* 모든 연산 블록이 항상 계산됨
* MUX로 출력만 선택 -> 비효율적
* 저전력 설계에서는 개선 필요


### Verilog 모듈 기반 설계

* 모듈은 하드웨어 블록의 재사용을 가능하게 한다
* 가독성, 유지보수, 검증이 쉬워진다
* ALU는 adder, subtractor, multiplier 모듈로 분리 가능

## 이진수 반올림(Binary Rounding)

### 1. 기본 상황 설정

* 고정소수점(FXP)에서 소수 비트 수를 줄일 때 반올림이 필요하다.
* 목표:

  * f비트 소수 -> k비트 소수 (k < f)


### 2. 기본 반올림 규칙 (Round to Nearest)

#### 핵심 규칙

> 버릴 비트 중 첫 번째 비트(guard bit)가 1이면 올림, 0이면 그대로 둔다.

### 용어

* 유지 비트: 남길 소수 비트
* Guard bit: 유지 비트 바로 다음 비트
* Remaining bits: 그 뒤에 오는 비트들


### 3. 단계별 절차

1. 목표 소수 비트 수만큼 유지한다
2. 그 다음 비트(guard bit)를 확인한다
3. guard bit = 1 -> 유지 비트에 +1
4. guard bit = 0 -> 그대로 유지
5. 올림으로 캐리가 발생하면 상위 비트로 전파된다


### 4. 간단한 예제

#### 예제 1: 올림 발생 X

```
원래 값:  0.101001
목표:     소수 3비트
유지:     0.101 | 001
guard = 0 -> 그대로

결과: 0.101
```


#### 예제 2: 올림 발생 O

```
원래 값:  0.101101
목표:     소수 3비트
유지:     0.101 | 101
guard = 1 -> 올림

0.101 + 0.001 = 0.110
```


### 5. 캐리 전파 예제 (중요)

```
원래 값:  0.111100
목표:     소수 3비트
유지:     0.111 | 100
guard = 1 -> 올림

0.111 + 0.001 = 1.000
```

결과:

```
1.000
```

- 소수부 캐리가 정수부로 올라간다


### 6. 고정소수점 실제 예제 (수업 스타일)

#### 0.8 -> 0.4 포맷

```
0.10001000
유지:     0.1000 | 1000
guard = 1 -> 올림

결과: 0.1001
```


### 7. 음수 이진수 반올림 (2’s complement)

#### 원칙

* 양수와 동일한 규칙 적용
* 2의 보수 표현에서는 비트 패턴 기준으로 반올림한다

예:

```
-0.101011  (2’s complement)
목표: 소수 3비트
-> guard bit 기준으로 동일 처리
```

- "음수라서 반대로" 이런 거 없다. 비트 기준이다.


### 8. Truncation(절단)과의 차이

#### Truncation

* 그냥 뒤를 버림

```
0.101111 -> 0.101
```

#### Rounding

```
0.101111 -> 0.110
```

- 반올림이 평균 오차가 작다


### 9. Round-to-Nearest-Even (참고, 시험에 나오면 말해라)

#### 규칙

* 정확히 중간(1000…)일 때
* 마지막 유지 비트가 짝수면 유지, 홀수면 올림

예:

```
0.1000 | 1000
-> 마지막 유지 비트 = 0 (짝수)
-> 그대로 유지
```

실무/IEEE 754에서 사용되지만
이 수업에서는 보통 안 쓴다.


### 10. 한 줄 요약 (시험용)

> 이진수 반올림은 유지할 비트 다음의 guard bit를 기준으로 하며, guard bit가 1이면 올림, 0이면 그대로 유지하고 캐리는 상위 비트로 전파된다.


### 11. FXP 설계에서 꼭 기억할 것

* 반올림 위치 = fraction bit 줄이는 지점
* 곱셈 후 비트폭 줄일 때 반드시 필요
* Truncation은 빠르지만 오차가 커진다