# 순차 논리 설계 (Sequential Logic Design)

## 순차 논리의 기초 (Fundamentals of Sequential Logic)

### 정의와 특성 (Definition and Characteristics)

* **순차 논리 회로(Sequential Logic Circuit)**란
  출력이 현재 입력 값뿐만 아니라 **과거 입력의 순서와 이력**에 의존하는 논리 회로를 의미한다.
* 조합 논리와의 핵심 차이:

  * 과거 데이터를 **기억해야 하며**
  * 상태(state) 또는 메모리를 유지해야 한다.
* 출력은 단순히 현재 입력만으로 결정되지 않고, **이전 입력의 히스토리**에 의해 제어된다.
* 시간에 따라 정보를 저장할 수 있는 **메모리 구성 요소**를 포함한다.
* “보통 메모리의 역할”
  → 메모리는 순차 논리와 조합 논리를 구분하는 **본질적인 요소**이다.

## 비동기 순차 논리 vs 동기 순차 논리

(Asynchronous vs Synchronous Sequential Logic)

### 비동기 순차 논리 (Asynchronous Sequential Logic)

* 클록 신호를 사용하지 않는다.
* 일반적으로 **래치(latch)**로 구현된다.
* 입력이 변하면 즉시 반응한다.
* **레벨 트리거(Level-triggered)** 방식이다.
* 예:

  * 기준 클록 없이 입력 레벨 변화를 감지하는 비동기 카운터

### 동기 순차 논리 (Synchronous Sequential Logic)

* **주기적인 클록 신호**를 사용한다.
* 일반적으로 **플립플롭(flip-flop)**으로 구현된다.
* 모든 상태 변수는 **클록에 맞춰 동시에** 변한다.
* **엣지 트리거(Edge-triggered)** 방식이다.
* 현대 디지털 설계에서 선호된다.
* **유한 상태 머신(FSM, Finite State Machine)**이라고 부른다.
* > “동기 순차 논리 회로는 플립플롭으로 구현할 수 있으며,
  > 플립플롭이 바로 메모리 소자이다.”

## 조합 논리 vs 순차 논리 비교

(Combinational vs Sequential Logic Comparison)

### 조합 논리 (Combinational Logic)

* 입력이 바뀌면 논리 지연 후 출력이 변한다.
* 메모리 요소가 없다.
* 예:

  * 가산기, 멀티플렉서, 디코더
* 신호 루프는 피해야 한다.

### 순차 논리 (Sequential Logic)

* 신호는 **주기적인 클록 엣지**에 따라 변한다.
* 메모리 요소(래치 또는 플립플롭)를 포함한다.
* 래치/플립플롭은 회로를 분리하는 저장 장치 역할을 한다.
* 한 클록 주기 동안 입력이 변하지 않도록 보장한다.

## 래치와 플립플롭 (Latches and Flip-Flops)

### 래치: 레벨 트리거 메모리 (Latch: Level-Triggered Memory)

#### RS 래치 (Reset-Set Latch)

* 동작:

  * R(Reset) = High → q = 0
  * S(Set) = High → q = 1
* 입력 변화에 즉시 반응한다.
* 현재 입력 레벨에 따라 출력이 변한다.
* 구현:

  * NOT, AND, OR 게이트의 조합
* 핵심 특성:

  * **클록 엣지가 아니라 입력 레벨**에 의해 상태가 유지된다.
* > “레벨 1을 받으면 출력을 감지하므로, 출력 파형이 이런 형태를 가진다.”

#### 래치의 한계

* 입력이 언제 변하든 출력이 즉시 변한다.
* 엣지 검출 메커니즘이 없다.
* 복잡한 회로에서 타이밍 문제를 유발할 수 있다.

### 플립플롭: 엣지 트리거 메모리 (Flip-Flop: Edge-Triggered Memory)

#### 정의와 특성

* 플립플롭은 **엣지 트리거 방식**의 메모리 회로이다.
* 입력을 감시하지만, 출력은 **클록 엣지에서만** 변한다.
* 일반적으로 **마스터–슬레이브 구조의 두 래치**로 구현된다.
* 클록 입력에 `>` 기호로 표시된다.
* > “클록의 엣지를 받아서 데이터를 감지한다.”

### SR 플립플롭 (동기식)

* 기능은 SR 래치와 동일하나 **클록 엣지에서만** 동작한다.
* R = High → q = 0 (클록 엣지에서만)
* S = High → q = 1 (클록 엣지에서만)
* 출력은 지정된 클록 엣지에서만 변경된다.
* 마스터–슬레이브 구조로 Set과 Reset의 동시 활성 문제를 방지한다.

### D 플립플롭 (Data Flip-Flop)

* SR 플립플롭의 단일 입력 버전이다.
* D = High → SET
* D = Low → RESET
* > “Q는 클록 엣지에서 D를 따른다.”
  > “Q는 클록 엣지에서 D를 저장한다.”
* 동작:

  * 클록 엣지에서 입력 D를 저장
  * 출력 Q는 저장된 값을 유지
  * 다음 클록 엣지까지 값이 유지된다.
* 가장 단순한 분산 메모리 구현이다.
* 빠르지만 회로 면적이 크다.

### 엣지 검출 메커니즘 (Edge Detection Mechanism)

* 양의 엣지 (Positive edge): 0 → 1
* 음의 엣지 (Negative edge): 1 → 0
* 인버터 지연 회로로 엣지를 검출할 수 있다.
* 하나의 플립플롭으로 양/음 엣지를 동시에 검출할 수는 없다.
* 하나의 플립플롭은 **하나의 엣지 타입만 선택**해야 한다.
* 여러 플립플롭이 서로 다른 엣지를 사용하는 것은 가능하다.

#### 중요한 설계 제약

* > “하나의 플립플롭으로 양의 엣지와 음의 엣지를 동시에 검출할 수 없다.”
* 권장:

  * 동기 시스템 전체에서 **하나의 엣지 타입(보통 양의 엣지)**을 일관되게 사용하라.

## 래치 vs 플립플롭 비교

| 항목       | 래치          | 플립플롭     |
| -------- | ----------- | -------- |
| 트리거 방식   | 레벨 트리거      | 엣지 트리거   |
| 입력 반응    | 즉시 반응       | 클록 엣지에서만 |
| 메모리 유지   | 입력 레벨 유지 동안 | 다음 클록까지  |
| 클록 필요 여부 | 필요 없음       | 필수       |
| 구현 방식    | 게이트 기반      | 마스터–슬레이브 |

* > “래치는 입력 레벨을 기준으로 데이터를 유지할지 결정하고,
  > 플립플롭은 클록 엣지를 기준으로 데이터를 감지한다.”

## 타이밍 제약 (Timing Constraints)

### 셋업 타임 (Setup Time)

* 클록 상승 엣지 **이전에** 데이터 D가 준비되어 있어야 한다.
* 정의:

  * 클록 엣지 전 입력이 안정되어 있어야 하는 시간
* 위반 시:

  * 데이터가 제대로 샘플링되지 않을 수 있다.
  * 메타안정성 발생 가능
* > “데이터 D는 클록 상승 엣지를 받기 전에 미리 준비되어야 한다.”

### 홀드 타임 (Hold Time)

* 클록 엣지 이후에도 입력 데이터가 일정 시간 유지되어야 한다.
* 정의:

  * 클록 엣지 후 입력이 안정적으로 유지되어야 하는 시간
* 데이터 손상을 방지한다.
* > “안정적인 Q를 만들기 위해 입력 D는 일정 시간 유지되어야 한다.”

### 전파 지연 (Clock-to-Q Delay)

* 클록 엣지를 받아도 출력 Q는 즉시 변하지 않는다.
* 회로의 저항과 커패시턴스로 인해 지연이 발생한다.
* 원인:

  * 배선 저항
  * CMOS 커패시턴스
  * 게이트 지연
* 셋업/홀드 타임보다 일반적으로 크다.
* 배선 길이, 게이트 수, 트랜지스터 크기로 제어 가능하다.

### 타이밍 제약 요약

* 핵심 파라미터 3가지:

  * 셋업 타임
  * 홀드 타임
  * 전파 지연
* 셋업/홀드 타임:

  * 사용하는 D 플립플롭에 의해 **사전에 결정**
  * 셀 라이브러리에서 제공됨
* 전파 지연:

  * 회로 설계로 조절 가능
* 설계 시 셋업/홀드를 만족하면서 전파 지연을 관리해야 한다.

## 레지스터 (Registers)

### 정의와 목적

* 여러 개의 D 플립플롭을 사용해 **다중 비트 데이터**를 저장한다.
* 임시 데이터 버퍼 역할을 한다.
* > “메모리란 어떤 데이터를 일정 시간 동안 기억하는 장치이다.”

### 메모리 계층과 특성

* 레지스터 파일(RF):

  * 가장 빠르다
  * 메모리 밀도는 가장 낮다
  * 비트당 MOSFET 수가 많다
  * 면적과 전력 소모가 크다
* > “가장 빠르지만 다른 메모리보다 면적과 전력을 많이 요구한다.”

#### 메모리 계층 비교

* 밀도: RF < SRAM < DRAM < 하드디스크
* 속도: RF > SRAM > DRAM > 하드디스크

### 클록 기반 레지스터 동작

* 클록 입력을 받는다.
* 데이터는 클록 엣지에서만 갱신된다.
* enable 신호로 여러 클록 동안 값 유지 가능하다.

## 응용 예제 (Applications and Examples)

### 예제 1: 가산기 (조합 논리)

* 입력 a, b를 받아 덧셈 결과 출력
* 누적 불가 (메모리 없음)
* 입력이 변하면 즉시 출력 변경
* 8비트 입력 → 9비트 출력 필요

### 예제 2: 누산기 (Accumulator, 순차 논리)

* 목적:

  * 덧셈 결과를 단계적으로 누적
* 구성:

  * 가산기(조합 논리)
  * 레지스터(순차 논리)
  * 피드백 경로
* 동작:

  * 현재 결과 = 이전 누적값 + 새로운 입력
  * 레지스터는 클록 엣지에서만 갱신
* 문제:

  * 전원 인가 시 초기값이 랜덤
* 해결:

  * reset 신호 추가
  * 누산 시작 전 0으로 초기화

### 예제 3: 카운터

* 증가, 감소, 유지 기능
* 제어:

  * reset, up, down, load, hold
* 상태 다이어그램으로 전이 정의

### 예제 4: 신호등 제어기

* 초기 상태:

  * 남북: 녹색
  * 동서: 적색
* 동서 차량 감지 시 상태 전이
* FSM으로 구현
* 상태 인코딩:

  * 원-핫 또는 이진 인코딩

## 유한 상태 머신 (FSM)

### FSM 기본 개념

* 동기 순차 논리 설계 방식
* 상태는 다음 클록 엣지까지 유지된다.
* 상태 갱신은 클록 엣지에서만 발생한다.

### FSM 동작 흐름

1. 현재 상태, 입력, 클록 수신
2. 현재 상태 + 입력 → 다음 상태 및 출력 결정
3. 클록 엣지에서 상태 및 출력 갱신

### 상태 다이어그램

* 원: 상태
* 원 내부: 출력
* 화살표: 상태 전이
* 화살표 위: 입력 조건

### 상태 할당 방식

#### 원-핫 인코딩

* 상태 수 N → N비트 사용
* 하나의 상태만 1
* 예: 0001, 0010, 0100, 1000

#### 이진 인코딩

* 최소 비트 수 사용
* 예: 2비트로 4상태
* 디코딩 로직 필요

## Verilog 구현

### 순차 always 블록

```verilog
always @(posedge clk) begin
  // 순차 논리
end
```

* `posedge`, `negedge` 사용 시 순차 논리
* 감도 리스트는 매우 중요하다.

### Blocking vs Nonblocking 할당

#### Blocking (=)

* 즉시 평가 및 대입
* 순차 논리 모델링에 부적합
* 사용 비권장

#### Nonblocking (<=)

* RHS 모두 평가 후 동시 대입
* 순차 논리 동작을 정확히 모델링
* 순차 회로에 필수

#### 권장 사항

* 순차 always 블록에서는 **항상 nonblocking 사용**
* 조합 논리에서만 blocking 사용
* 레이스 컨디션 방지

## 동기 회로 설계 원칙

* 하나의 클록 엣지 타입을 일관되게 사용하라.
* reset/set 같은 예외 신호만 비동기로 허용하라.
* 같은 플립플롭에서 posedge/negedge 혼용 금지

## 핵심 개념 요약

* 순차 논리는 **시간과 메모리**를 다룬다.
* 상태 기반 연산과 누적이 가능하다.
* FSM은 순차 논리 설계의 표준 방법이다.
* 좋은 하드웨어 설계는 **좋은 블록 다이어그램**에서 시작한다.