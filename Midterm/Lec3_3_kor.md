# ASIC 3장 정리 - 3

## CMOS 구현 Introduction 

좋다, 이전에 우리는 불 대수의 특성과 성질을 이용한 논리 최소화 방법에 대해 이야기했었다.
또한 진리표로부터 얻은 논리 연산을 구현하기 위한 기본적인 프로그래밍 방법의 일부를 이미 배웠다.
물론 우리는 진리표에서 얻은 표준형(normal form)을 직접 사용하여 회로를 구현할 수도 있고,
카르노 맵(Karnaugh map)이나 다른 방법을 사용하여 논리를 최소화한 뒤, 그 최소화된 버전으로 프로그램을 구현할 수도 있다.
내가 말하고자 하는 것은, 어떤 논리 회로 프로그램을 작성하려면 그 프로그램은 표준 셀(standard cell)들의 조합으로 변환되어야 한다는 것이다.
각 표준 셀은 기본적인 기능 모델뿐 아니라 타이밍 정보와 레이아웃 정보도 포함한다.
따라서 다음 주제는 표준 셀 설계를 실현하기 위한 레이아웃 정보에 대한 고려가 될 것이다.
이러한 물리적 레이아웃 설계, 혹은 표준 셀 코어의 구현을 논리 회로의 CMOS 구현이라고 부른다.

## 전자 회로 복습

이제 세부 내용으로 들어가기 전에, 기본 전자 회로에서 배운 내용을 잠시 복습해보자.
MOS 소자를 하나 가지고 있다고 가정하자. 전원 전압 $V_{DD}$가 있고, 저항도 존재한다고 하자.
전류가 이런 방향으로 흐른다고 가정하면, 만약 이 MOSFET이 n형이라면 그에 해당하는 회로 기호로 표현할 수 있다.
앞서 말했듯이 MOSFET 소자는 대칭적인 구조를 가지는 소자이기 때문에, 실제 전류의 방향은 명확하지 않다.
즉, 소스(source)와 드레인(drain) 사이에 전압을 인가하기 전에는 전류의 실제 방향을 알 수 없다.
앞서 언급했듯이, 이쪽 단자를 소스(source) 라 하고, 이쪽 단자를 드레인(drain) 이라고 부른다.
전류 방향을 고려할 때, 전류는 드레인에서 소스로 흐른다고 본다.
왜냐하면 전자는 소스에서 출발하기 때문이다. 전자의 출발점이 바로 소스이므로 그렇게 부른다.
반대로 드레인(drain) 은 전자가 흘러 들어가는 '싱크(sink)' 역할을 하기 때문에 그렇게 이름 붙여졌다.
> 약간 하수구 구멍같은 느낌

### Saturation
이제 우리가 알고 있는 것을 살펴보자.
드레인 전압 $V_{DD}$가 충분히 크다고 가정하되, 일정한 값으로 유지한다고 하자.
이때 게이트 전압을 인가하면, 전류가 MOSFET을 따라 흐르게 된다.
이때의 특정 전압을 임계 전압(threshold voltage) 이라고 부른다.
MOSFET을 통해 흐르는 전류는 다음과 같은 관계식으로 결정된다.

게이트 전압이 충분히 커지면, 전류는 $V_{DS}$ 값에 따라 포화(saturation)하게 된다.
이 구간을 트라이오드(triode) 영역 혹은 선형(linear) 영역, 그리고 포화(saturation) 영역이라고 부른다.
두 영역의 경계 조건은 $V_{DS} = V_{GS} - V_{TH}$ 이다.
최종적으로 MOSFET의 포화 전류 $I_{D(sat)}$는 다음과 같다.
$$
I_{D(sat)} = \frac{1}{2} \mu_n C_{ox} \frac{W}{L} (V_{GS} - V_{TH})^2
$$
여기서 볼 수 있듯이, $V_{GS}$가 임계 전압 $V_{TH}$보다 커지면 MOSFET이 '켜지게(turn on)' 되고,
게이트 전압이 더 커질수록 전류는 포화 상태에 이르게 된다.

### Switch
이제 입력 전압 $V_{IN}$이 일반적인 값에서 $V_{DD}$까지 변한다고 가정해보자.
그럼 어떤 일이 일어날까?
먼저 MOSFET을 살펴보면, 게이트 단자는 입력 전압 $V_{IN}$에 연결되어 있고,
소스(source)는 접지(ground)에, 드레인(drain)은 전원 공급 전압 $V_{DD}$에 연결되어 있다고 하자.

이제 $V_{IN}$을 낮은 전압(예: 0V)으로 인가하면, 게이트-소스 전압 $V_{GS}$는 0이 되어
임계 전압 $V_{TH}$보다 작다.
따라서 전류는 흐르지 않으며, MOSFET은 꺼진 스위치처럼 동작한다.

반대로, 만약 $V_{IN} = V_{DD}$이면 $V_{GS} = V_{DD}$가 된다.
일반적으로 $V_{DD}$는 약 1.0V, $V_{TH}$는 0.4~0.6V 정도이므로
이때 $V_{GS} > V_{TH}$가 되어 전류 $I_D$는 0이 아니다.

또한 드레인-소스 전압 $V_{DS}$는 $V_{GS} - V_{TH}$보다 크다.
왜냐하면 드레인 전압이 게이트 전압과 같은 $V_{DD}$로 설정되어 있기 때문이다.
따라서 항상 $I_D > 0$이며, 이런 경우 MOSFET은 켜진 스위치(turn-on switch) 로 동작한다.
물론 MOSFET 내부에는 전류가 흐르는 채널이나 논리적인 구성 요소가 포함되어 있다.

이 슬라이드에서 볼 수 있듯이, 입력 값이 디지털화된 경우를 생각해보자.
게이트에 높은 전압('1')을 인가하면, MOSFET은 항상 켜진 스위치처럼 동작한다.
반대로 입력이 낮은 전압('0')일 경우에는 꺼진 스위치처럼 동작한다.
이것이 nMOS의 기본적인 동작이다.

하지만 pMOS의 경우 상황이 반대이다.
게이트 입력 $V_{IN}$을 인가할 때, pMOS는 소스가 $V_{DD}$, 드레인이 접지(GND)에 연결되어 있다고 하자.
만약$ V_{IN} = V_{DD}$라면, 전류는 흐르지 않는다. 즉, pMOS는 꺼진 스위치처럼 동작한다.
그러나 $V_{IN} = 0$과 같이 낮은 전압을 인가하면, 소스와 드레인 간의 전압차가 커지고
이때 pMOS는 켜진 스위치처럼 동작하게 된다.

pMOS의 포화 전류(saturation current)는 다음과 같다.
$$
I_{D(sat)} = \frac{1}{2} \mu_p C_{ox} \frac{W}{L} (V_{SG} - |V_{TH}|)^2
$$
여기서 $V_{SG}$는 소스-게이트 전압이다.

결론적으로, MOSFET은 게이트에 인가된 전압에 따라 스위치처럼 동작한다고 볼 수 있다.

여기서 볼 수 있듯이, nMOS의 게이트가 접지(GND)에 연결되어 있다면, MOSFET은 꺼진 스위치처럼 동작한다.
반대로 MOSFET의 게이트가 전원 공급 전압 $V_{DD}$에 연결되어 있다면, 켜진 스위치처럼 동작한다.

그렇다면 pMOS의 경우는 어떨까?
pMOS의 게이트가 접지에 연결되어 있다면, 그것은 켜진 스위치처럼 동작한다.
하지만 게이트에 높은 전압(즉, $V_{DD}$을 인가하면, 꺼진 스위치처럼 동작한다.

이제 두 종류의 MOSFET을 직렬로 연결한다고 가정해보자.
직렬로 연결된 경우, 두 MOSFET이 모두 켜져야만 연결이 성립한다.
즉, 두 스위치가 동시에 ON 상태일 때만 전류가 흐른다.

nMOS의 경우, 게이트 입력을 G1, G2라고 하면,
이 연결이 성립하기 위한 논리 조건은 G1 AND G2 = 1 이다.

반대로 pMOS의 경우는 조건이 반대이다.
두 게이트 G1, G2 모두 논리적으로 '0' (low voltage)일 때 연결이 성립한다.

그렇다면 이번에는 MOSFET을 병렬로 연결한 경우를 생각해보자.
게이트 입력 G1 또는 G2 중 하나라도 '1'(논리 High)이면, 두 단자 A와 B는 서로 연결된다.
즉, G1 = 1이거나 G2 = 1이거나, 또는 둘 다 1인 경우에 A와 B가 연결된다.
이것이 바로 병렬 연결이 OR 동작을 수행하는 이유이다.

하지만 두 게이트 모두 접지('0')로 설정하면, 스위치는 꺼지고 A와 B는 연결되지 않는다.

pMOS의 경우는 반대로, 두 게이트 중 하나라도 '1'이면 스위치가 꺼지고,
둘 중 하나라도 '0'이면 A와 B 노드가 연결된다.

정리하자면,
pMOS는 게이트에 낮은 전압(예: GND)이 인가될 때 켜지고, 높은 전압(예: $V_{DD}$)일 때 꺼진다.
따라서 pMOS를 적절히 조합하면 AND와 OR 연산을 모두 구현할 수 있다.

한편 nMOS는 게이트에 높은 전압($V_{DD}$)이 인가될 때 켜지므로,
nMOS와 pMOS를 직렬 또는 병렬로 조합하면 AND 또는 OR 논리 연산을 구현할 수 있다.

하지만 문제는, 지금까지 이야기한 방식은 완전한 해결책이 아니라는 점이다.
이후에 다룰 CMOS 소자 구조에서는 이러한 문제가 발생하지 않지만,
단일 트랜지스터 스위칭 개념만으로 AND나 OR 연산을 구현하려 하면 몇 가지 한계가 생긴다.

예를 들어, MOSFET을 통해 '1'(High)을 전달하려 한다고 가정하자.
MOSFET의 게이트에 $V_{DD}$를 인가하고, 드레인에도 $V_{DD}$를 연결해
출력 단자에서 $V_{DD}$가 그대로 전달되길 기대한다면, 실제로는 그렇게 되지 않는다.

앞서 말했듯이, MOSFET은 $V_{DS} > V_{GS} - V_{TH}$일 때만 전류가 흐른다.
즉, 드레인 전압이 게이트 전압과 같아지면, $V_{DS}$가 0이 되어 전류가 차단된다.

결국 출력 전압은 완전한 $V_{DD}$가 아니라 $V_{DD} - V_{TH}$ 수준으로 떨어진다.
왜냐하면 MOSFET이 임계 전압(Threshold Voltage) 만큼의 손실을 만들기 때문이다.

따라서 게이트가 $V_{DD}$일 때 $V_{GS} = V_{TH}$가 되면,
MOSFET은 더 이상 켜진 상태를 유지하지 못하고 꺼지게 된다.

물론, 만약 전달하려는 신호가 '0'(즉, 일반적인 low 전압)이라면 문제없이 잘 전달된다.
하지만 '1'(즉, $V_{DD}$)을 전달하려 할 경우,
출력 신호는 $V_{DD} - V_{TH}$만큼 감쇠된 값으로 나타난다.
즉, 출력의 논리 '1'이 완전한 '1'이 아니라 약간 깎인(high degraded) 상태가 된다.

그렇다면 pMOS의 경우는 어떨까?
게이트 전압을 0V로 두고, $V_{DD}$ 신호를 전달하려 한다고 하자.
이 경우 전압차가 충분히 크기 때문에 $V_{DD}$는 비교적 잘 전달된다.

그러나 자세히 보면 여전히 한계가 있다.
소스-게이트 전압 $V_{SG}$는 $V_{DD}$이고, 드레인-소스 전압 $V_{SD}$ 또한 $V_{DD}$ 근처이다.
하지만 만약 우리가 전달하려는 값이 $V_{DD}$가 아니라 '0'(일반적인 low 전압)이라면,
$V_{SG}$는 작아지게 되고, $V_{SG} > V_{TH}$ 조건을 만족하지 못해 전류가 흐르지 않는다.

결과적으로 pMOS의 출력 전압도 임계 전압만큼 감소하며,
전압이 점점 낮아져 $V_{SG} = V_{TH}$에 도달하면 더 이상 전류가 흐르지 않는다.

즉, pMOS도 완벽한 스위치가 아니며, 출력은 결국 임계 전압 정도의 포화 전압에서 멈춘다.

따라서 pMOS에 일반적인 전압을 인가하면, 최종적으로 포화되는 전압은 임계 전압 수준에 머문다.
이는 nMOS의 경우와 반대되는 현상이다.

결국 nMOS와 pMOS 모두 완벽한 이상적 스위치가 아니며,
'1' 또는 '0'을 전달할 때 모두 어느 정도의 전압 감쇠가 발생한다.

이러한 문제를 보완하기 위해, 우리는 이미 알고 있듯이
nMOS는 논리 '0'을 잘 전달하고, pMOS는 논리 '1'을 잘 전달한다는 점을 활용한다.
따라서 두 소자를 결합해 서로의 약점을 보완하는 구조가 필요하며,
이것이 바로 CMOS 정적 논리 회로(CMOS Static Logic Circuit) 의 개념이다.

따라서 이제부터는 NMOS와 PMOS를 함께 사용하여 논리 게이트를 설계하게 된다.
앞서 언급했듯이, NMOS의 장점은 입력이 논리 '0'일 때 전류를 잘 전달한다는 점이다.
즉, NMOS는 논리 '0'을 완벽히 전달할 수 있다.

반면, PMOS는 높은 전압(논리 '1')을 전달하는 데 매우 유리하다.
그래서 우리는 PMOS를 전원 공급단(VDD) 근처에 배치하고,
NMOS는 접지(GND) 근처에 배치하여 서로의 특성을 보완하도록 설계한다.

PMOS 회로는 Pull-up Network(PUN) 로 사용되고,
NMOS 회로는 Pull-down Network(PDN) 로 사용된다.

즉, 출력 포트가 있을 때,
Pull-up Network는 출력을 높은 전압(VDD 방향)으로 끌어올리는 역할을 하며,
그래서 이를 “Pull-up Network”라고 부른다.

반대로 Pull-down Network는 출력을 접지 쪽으로 당겨 낮은 전압(0V)을 만드는 역할을 한다.
즉, 출력 노드가 '0'이 되어야 할 때 NMOS가 이를 담당한다.

이처럼 상보적인 두 종류의 MOSFET, 즉 NMOS와 PMOS를 각각 Pull-down과 Pull-up 네트워크로 사용함으로써
CMOS 회로를 구성할 수 있다.

이러한 회로 구조를 이용하면 다양한 논리 연산(logic operation) 을 구현할 수 있다.
이후 예제들을 통해 구체적인 설계 방법을 살펴볼 것이다.

다음 내용으로 넘어가기 전에,
Pull-up과 Pull-down 네트워크를 이용해 회로를 구성했을 때의 주요 특성을 먼저 살펴보자.

만약 두 네트워크 중 하나만 연결되어 있다면,
출력은 $V_{DD}$이거나 GND가 되어 논리 '1' 또는 '0'으로 결정된다.

하지만 Pull-up과 Pull-down 네트워크가 동시에 켜져 있다면,
출력은 $V_{DD}$와 GND 양쪽에 동시에 연결된다.
이 경우 출력 전압은 정의되지 않으며, 논리적으로 'X' 상태(unknown state)가 된다.
이러한 상황은 우리가 의도하는 정상적인 회로 동작이 아니다.

반대로, 두 네트워크가 모두 꺼져 있다면,
출력 노드는 어느 쪽에도 연결되지 않은 '부동(floating)' 상태가 된다.
이런 노드를 Z 상태(high impedance node) 라고 부른다.
이 역시 기대하지 않는 비정상적인 동작이다.

따라서 CMOS 회로의 정상적인 출력은 항상 논리 0 또는 1 중 하나여야 한다.

이제 CMOS 논리 회로의 대표적인 예로 NAND 게이트 를 살펴보자.
NAND 게이트의 동작은 다음과 같다:
입력 A와 B가 모두 1이면 출력은 0이 되고,
그 외의 경우에는 출력이 1이 된다.

이를 CMOS 회로로 구현하면 다음과 같은 구조를 갖는다.

* 입력 A와 B가 모두 '0'이면, 두 NMOS는 꺼지고 두 PMOS는 켜진다.
  따라서 출력 노드는 $V_{DD}$에 연결되어 출력 = 1 이 된다.

* 입력 중 하나(A 또는 B)가 '0'이면,
  대응하는 NMOS는 꺼지고 PMOS는 켜진다.
  따라서 접지(GND)는 차단되고, 출력은 여전히 $V_{DD}$에 연결되어 1을 유지한다.

* 입력 A와 B가 모두 '1'이면,
  두 NMOS는 켜지고 두 PMOS는 꺼진다.
  따라서 출력은 GND에 연결되어 출력 = 0 이 된다.

즉, NMOS의 직렬 연결과 PMOS의 병렬 연결을 이용하면
CMOS 기술로 NAND 게이트를 완벽히 구현할 수 있다.

이제 다음 질문을 해보자.
좋다, NAND 게이트는 이렇게 CMOS 회로로 설계할 수 있다는 것을 이해했다.
그렇다면 NOR 게이트, AND 게이트, NOT 게이트, XOR 게이트 등은 어떻게 설계할 수 있을까?

가장 간단한 형태의 CMOS 논리 회로부터 보자.
그것은 바로 인버터(inverter, NOT 게이트) 이다.

인버터는 하나의 입력만을 받아서 그 반대의 출력을 만든다.
즉, 입력이 '1'이면 출력은 '0', 입력이 '0'이면 출력은 '1'이 된다.

이 회로에서 입력이 높을 때(high voltage), NMOS는 켜지고
출력은 접지(GND)에 연결되어 낮은 값(0)을 출력한다.

반면, PMOS는 동작 방식이 반대이다.
입력이 낮을 때(low voltage), PMOS가 켜져서 출력을 $V_{DD}$로 연결한다.

이제 생각해보자.
좀 더 복잡한 논리 연산을 이런 방식으로 어떻게 구현할 수 있을까?

### 예시1 - AND
예를 들어, AND 게이트를 설계한다고 하자.
먼저 출력의 이중(dual) 형태를 만들어야 한다.
즉, $Y = A \text{ AND } B$라면, 그 보수 형태는 $Y' = \text{NOT}(A \text{ AND } B)$이다.

우리는 이미 A와 B의 AND 연산이 NMOS의 직렬 연결(series connection) 로 구현된다는 것을 알고 있다.
즉, 두 NMOS를 직렬로 연결하면 A·B 연산이 실현된다.

하지만 NAND 게이트는 AND 결과를 반전시킨 형태이므로,
이 AND 회로 뒤에 NOT 동작이 추가되어야 한다.
즉, NAND의 출력은 AND 결과의 보수(inversion) 이다.

따라서 출력의 보수를 얻기 위해 NMOS 쪽에서는
A와 B를 직렬로 연결하여 Pull-down 네트워크를 구성한다.
이 네트워크는 출력이 '0'이 되어야 할 때 GND로 연결되는 역할을 한다.

그렇다면 PMOS 쪽의 Pull-up 네트워크는 어떻게 될까?
PMOS 회로는 $Y$ (즉, AND의 반대값)을 직접 생성해야 한다.

그러므로 입력은 단순히 A, B가 아니라, 그 반대인 A̅와 B̅ 이 되어야 한다.
왜냐하면 PMOS의 게이트 입력에는 반전된 신호가 들어가기 때문이다.
즉, NMOS의 입력과 반대 극성으로 PMOS 게이트를 제어해야 한다.

좋다. 이제 출력을 살펴보자.
출력은 단순히 $\text{NOT}(A \cdot B)$ 이다.

드모르간의 법칙(De Morgan's Law)을 적용하면,
$$
\text{NOT}(A \cdot B) = (\text{NOT}A) + (\text{NOT}B)
$$
즉, AND 연산의 부정은 OR 연산으로 바뀌고, 각 입력은 반전된다.

따라서 PMOS 회로에서는 A̅와 B̅를 병렬로 연결하면 된다.
이 병렬 구조가 OR 동작을 수행하게 된다.

결과적으로 NMOS의 직렬 연결과 PMOS의 병렬 연결을 결합하면
CMOS 방식으로 NAND 게이트를 구현할 수 있다.

### 예시2 - NOR
이제 또 다른 예로 NOR 게이트를 보자.
NOR 게이트 역시 Pull-down 네트워크와 Pull-up 네트워크로 구성된다.

* Pull-down 네트워크는 출력의 이중(dual) 을 사용해야 하므로,
  $Y = \text{NOT}(A + B)$의 보수는 $A + B$이다.

* 반면 Pull-up 네트워크는 $Y = \text{NOT}(A + B)$ 자체를 구현해야 한다.
  드모르간 법칙에 따라
  $$
  \text{NOT}(A + B) = (\text{NOT}A) \cdot (\text{NOT}B)
  $$
  따라서 PMOS에서는 A̅와 B̅를 직렬로 연결해야 한다.
  이렇게 하면 AND 연산이 구현된다.

결국 Pull-down 네트워크는 OR 동작을 수행하므로,
NMOS 두 개를 병렬로 연결하면 된다.

반면 Pull-up 네트워크는 A̅와 B̅를 입력으로 받아
AND 동작을 수행해야 하므로, 두 PMOS를 직렬로 연결해야 한다.

이 원리는 인버터의 경우에도 똑같이 적용된다.
인버터의 Pull-down 네트워크는 $Y = \text{NOT}(A)$의 반대, 즉 $Y' = A$를 가진다.
Pull-up 네트워크는 반대로 A̅를 입력받아 PMOS 하나로 구성된다.
따라서 인버터는 단일 NMOS와 단일 PMOS 로 구현된다.

그렇다면 이번에는 NAND가 아니라, AND 게이트 자체를 직접 구현하려면 어떻게 해야 할까?
가장 간단한 방법은 Pull-down 네트워크부터 시작하는 것이다.

Pull-down 네트워크는 출력의 보수를 사용하므로,
$$
Y' = (AB)'
$$
즉, NAND 형태가 된다.
반면 Pull-up 네트워크는 $Y = AB$를 직접 구현해야 한다.

하지만 앞서 말했듯이, PMOS 게이트에는 항상 반전된 신호가 입력되어야 한다.
즉, A와 B 대신 A̅, B̅를 사용해야 하며,
이를 드모르간의 법칙으로 변환하면 다음과 같다.
$$
A \cdot B = \text{NOT}(\text{NOT}A + \text{NOT}B)
$$
즉, AND를 직접 구현하려면 내부적으로는 NOT–OR–NOT 구조를 거쳐야 한다.

결국 이는 NAND 게이트 두 개를 직렬로 연결하는 형태와 같아지지만,
이 방식은 비효율적이다.
왜냐하면 A와 B의 직접적인 입력이 아니라,
A̅, B̅와 같은 반전 신호를 별도로 만들어야 하기 때문이다.

이 문제를 해결하는 방법은 두 가지가 있다.

첫 번째 방법은, AND나 OR 게이트를 직접 설계하되
NAND나 NOR 게이트와 달리 NOT 연산이 없는 형태로 구성하는 것이다.

예를 들어 AND 게이트를 설계한다고 하면,
Pull-down 네트워크는 출력의 이중(dual)을 사용해야 하므로
$$
Y' = (A \cdot B)' = A' + B'
$$
가 된다.

반면 Pull-up 네트워크는 $Y = A \cdot B$를 그대로 사용한다.
그러나 PMOS 회로에서는 A, B 대신 반전된 입력 $A'$, $B'$가 사용되므로
결국 병렬 구조로 바뀌게 된다.

즉, NMOS 쪽에서는 직렬 연결을, PMOS 쪽에서는 반전 입력을 사용한 병렬 연결을 통해
AND 회로를 구현하게 된다.

결국 다음과 같이 된다.
Pull-down 네트워크는 A′와 B′를 입력으로 사용하는 병렬 연결 NMOS 2개로 구성되고,
Pull-up 네트워크는 A′와 B′를 입력으로 받는 직렬 연결 PMOS 2개로 구성된다.

이 방식으로도 AND 게이트를 만들 수 있지만,
문제는 A′와 B′ 신호를 생성해야 한다는 점이다.
즉, 각 입력마다 인버터가 하나씩 추가로 필요하다.

각 인버터는 NMOS와 PMOS 한 쌍으로 이루어져 있으므로,
입력 2개에 대해 총 4개의 MOSFET(NMOS 2개 + PMOS 2개) 가 더 필요하다.
따라서 전체적으로 AND 회로를 구성하려면 8개의 트랜지스터가 사용된다.

하지만 이보다 훨씬 효율적인 방법이 있다.
이미 우리는 NAND 게이트 + 인버터 조합이 AND와 동일한 기능을 수행한다는 것을 알고 있다.

즉, AND를 직접 구현하지 않고, NAND 게이트의 출력을 인버터로 한 번 더 반전시키면 된다.
이 경우, NAND 게이트(4개 트랜지스터) + 인버터(2개 트랜지스터)로
총 6개의 트랜지스터(NMOS 3개, PMOS 3개) 만으로 AND 게이트를 구성할 수 있다.

따라서 이 방식이 앞선 직접 구현 방식보다 면적 효율이 훨씬 높다.

이와 같은 현상은 OR 게이트 설계에서도 동일하게 나타난다.
물론 앞서 설명한 방식으로 OR 게이트를 설계할 수도 있다.
하지만 이 경우에도 입력 A와 B의 보수(A̅, B̅)를 만들어야 하므로,
두 개의 인버터가 추가로 필요하다 — 즉, NMOS 2개와 PMOS 2개가 더 들어간다.

결국 이러한 직접 구현 방식은 총 8개의 트랜지스터를 필요로 한다.
따라서 더 효율적인 방법은 NOR 게이트 + 인버터 조합을 사용하는 것이다.
NOR의 출력을 반전시키면 OR 게이트가 되므로,
트랜지스터 수를 줄이면서 동일한 기능을 얻을 수 있다.

좋다. 이제 좀 더 복합적인 논리 회로 예시를 살펴보자.
다음과 같은 함수를 목표로 한다고 하자:
$$
F = \overline{(A + B) \cdot C}
$$

먼저 Pull-down 네트워크를 설계하려면,
이 함수의 이중(dual) 을 구해야 한다.
De Morgan의 법칙에 따라
$$
F = (A + B) \cdot C
$$
이 된다.

따라서 Pull-down 네트워크는 이 $F'$ 형태를 따라야 하므로
병렬 연결된 (A + B) 블록과 직렬로 연결된 C로 구성된다.
즉, A와 B는 병렬 연결, 그리고 그 결과가 C와 직렬로 연결된다.

한편 Pull-up 네트워크는 원래 함수 $F = \overline{(A + B) \cdot C}$ 를 직접 구현한다.
PMOS는 반전 입력을 사용하므로, A̅, B̅, C̅를 입력으로 받아야 한다.
이 역시 De Morgan의 법칙을 적용하면
$$
F = \overline{(A + B) \cdot C} \Rightarrow F = (A' \cdot B') + C'
$$
형태로 표현되며,
PMOS는 이를 병렬 + 직렬 구조로 실현할 수 있다.

결과적으로 Pull-down 네트워크는 A, B 병렬 + C 직렬,
Pull-up 네트워크는 (A̅B̅ 직렬) + C̅ 병렬 로 구성된다.

Pull-up 네트워크를 좀 더 구체적으로 보면,
두 개의 분기(branch)로 구성된다.
하나는 C 단독 경로, 다른 하나는 A̅와 B̅의 직렬 연결 경로이다.

이 두 경로를 병렬로 연결하면 전체 Pull-up 네트워크가 완성된다.
결국 Pull-down과 Pull-up을 결합하면
목표 함수 $F = \overline{(A + B) \cdot C}$ 를 CMOS 논리 회로로 완벽히 구현할 수 있다.

좋다. 이제 XOR 게이트를 살펴보자.
먼저 Pull-down과 Pull-up 네트워크를 정의해야 한다.

출력 $F = A \oplus B$ 의 보수를 구하면 다음과 같다.
$$
F' = (A \oplus B)' = A B + A' B'
$$
드모르간의 법칙을 적용하면
$$
F' = (A + B') (A' + B)
$$
형태로 단순화할 수 있다.

이를 회로로 구현하면,
A와 B가 서로 다른 값일 때(즉, 한쪽이 1이고 다른 쪽이 0일 때)
Pull-down 네트워크가 켜지도록 구성된다.
결과적으로 Pull-down 네트워크는 A·B′ 와 A′·B 의 병렬 구조가 된다.

Pull-up 네트워크는 위의 보수 관계를 반대로 사용하여 구성된다.
즉, Pull-down 네트워크가 $A B' + A' B$ 로 되어 있다면,
Pull-up 네트워크는 그 반대의 조건 — $A' B' + A B$ — 로 설계된다.

이를 실제 CMOS 회로로 구성하면,
A와 B의 반전 조합이 서로 교차된 형태로 연결되며,
직렬과 병렬이 혼합된 구조를 갖는다.
이 결과, CMOS 구조로 XOR 동작을 완벽히 구현할 수 있다.

이 경우 회로를 따라가 보면,
A와 B의 반대 신호 조합이 각각 한 경로를 담당한다.
즉, 한쪽은 $A \bar{B}$, 다른 쪽은 $\bar{A} B$ 신호를 전달한다.

두 경로가 병렬로 연결되어 전체 XOR 회로가 완성된다.
결과적으로, $A \bar{B} + \bar{A} B$ 구조가 CMOS XOR 게이트의 Pull-up/Pull-down 조합으로 실현된다.

물론 동일한 개념을 3입력 XOR 게이트 에도 확장할 수 있다.
하지만 주의해야 할 점은,
3입력 XOR를 설계하려면 단순히 A·B 뿐만 아니라
각 입력의 반전 신호(A′, B′, C′)도 모두 준비되어야 한다는 것이다.

## 전하 이동도에 따른 L과 W 설계

지금까지는 CMOS 논리 회로를 설계하는 방법에 대해 다루었다.
하지만 MOSFET을 설계할 때는 항상 고려해야 하는 두 가지 주요 설계 인자가 있다.
바로 길이(L) 와 폭(W) 이다.

MOSFET을 흐르는 전류는 다음 식으로 표현된다.
$$
I_D = \frac{1}{2} \mu_n C_{ox} \frac{W}{L} (V_{GS} - V_{TH})^2
$$
여기서 $\mu_n C_{ox}$는 공정(technology)에 의해 결정되는 값이므로
설계자가 조절할 수 있는 요소는 W(폭)와 L(길이)뿐이다.

하지만 트랜지스터 면적이 너무 커지는 것은 바람직하지 않기 때문에,
일반적으로 L은 고정된 최소값(공정이 허용하는 최소 길이) 으로 설정한다.
따라서 설계 시 고려해야 할 주요 인자는 폭 $W$이다.
> 현대 공정에서 중요시하는게 Gate Length를 줄이는 것이니
이건 건들지 않는다. GAA-FET 같은게 저런거 줄이는 것.

이때 NMOS와 PMOS의 이동도(mobility) 차이를 고려해야 한다.

이동도(mobility)는 반도체 내 전하 운반자(charge carrier) 의 종류에 따라 달라진다.
NMOS에서는 자유전자(free electron) 가 주요 운반자이고,
PMOS에서는 정공(hole) 이 주요 운반자이다.

그러나 전자에 비해 정공의 이동은 훨씬 느리다.
따라서 NMOS의 이동도는 PMOS보다 일반적으로 훨씬 크다.
통상적으로 NMOS의 이동도는 PMOS보다 2~3배 정도 더 높다.

따라서 인버터(inverter)와 같은 회로에서
Pull-up(PMOS)과 Pull-down(NMOS)의 동작 속도(driving speed) 를 동일하게 맞추려면
두 소자의 구동 능력(driving strength)이 같아야 한다.

즉, 입력 전압이 중간 전압(VDD/2)일 때
NMOS와 PMOS가 동일한 구동 능력을 가진다면
출력 전압의 중간점은 정확히 0.5 × VDD 수준으로 유지된다.

만약 Pull-up(PMOS)이 너무 느리고 Pull-down(NMOS)이 너무 빠르다면,
출력 파형이 비대칭적으로 왜곡될 수 있다.
이러한 불균형은 방전(discharge) 과정에서 비정상적인 타이밍을 초래한다.

따라서 NMOS와 PMOS의 구동 능력을 맞춰야 한다.
NMOS의 이동도가 PMOS보다 2배 크다면,
PMOS의 폭(W)은 NMOS의 폭보다 2배 넓게 설계해야 한다.

앞서 본 식에서 알 수 있듯이,
전류는 이동도(μ)뿐 아니라 트랜지스터의 폭(W)에 비례한다.
따라서 이동도가 큰 소자는 폭을 줄이고,
이동도가 작은 소자는 폭을 키워야 구동 능력을 맞출 수 있다.

즉, 이동도가 작을수록 폭을 넓히면
구동 전류가 증가하고, 회로의 스위칭 속도도 빨라진다.
따라서 트랜지스터 폭을 키우는 것은 속도를 향상시키는 방법 중 하나 이다.

다음은 도핑 농도에 따른 이동도 변화 그래프이다.
앞서 말했듯이, 정공의 이동도는 전자의 이동도보다 훨씬 작다.
도핑 농도가 높을수록 NMOS와 PMOS 간 이동도 차이는 약 2배 정도지만,
도핑 농도가 낮을수록 그 차이는 3배 이상으로 커진다.

예를 들어 인버터 회로에서 두 가지 경우를 생각해보자.
첫째는 NMOS가 켜지는 경우, 둘째는 PMOS가 켜지는 경우이다.
이 두 경우 모두에서 NMOS와 PMOS의 구동 능력은 동일해야 한다.

만약 NMOS의 구동력이 PMOS보다 훨씬 크다면,
출력 전압은 대부분 낮은 쪽(즉, 0V 근처)에 치우치게 된다.

이렇게 되면 인버터의 중간 전압(medium voltage) 이 제대로 형성되지 않아
디지털 신호의 판별이나 전압 분할 과정에서 문제가 발생할 수 있다.

이를 해결하는 방법은 오직 하나 —
NMOS와 PMOS의 폭 비율을 조절하는 것이다.

즉, NMOS의 이동도가 PMOS보다 2배 크다고 가정하면,
PMOS의 폭(W)은 NMOS의 폭보다 2배로 설계해야 한다.

이제 AOI 회로의 트랜지스터 크기 비율(sizing) 을 계산해보자.

출력이 다음과 같은 형태라고 가정하자.
Pull-down 네트워크는 출력의 보수(dual)를 구현해야 하므로,
$$
F' = (A \cdot B + C)' = (A \cdot B)' \cdot C' = (A' + B') \cdot C'
$$
이 된다.

이 식에서 볼 수 있듯이, C는 다른 신호들과 직렬로 연결되고,
A와 B는 병렬로 연결되어 있다.
즉, Pull-down 네트워크는 (A || B) - 직렬 - C 구조로 이루어진다.

반면 Pull-up 네트워크는 원래 함수 $F = (A \cdot B + C)'$ 를 직접 구현한다.
이를 전개하면 $F = (A \cdot B)' \cdot C' = (A' + B') \cdot C'$ 이므로,
PMOS 쪽에서는 C가 직렬, A와 B는 병렬로 연결되어야 한다.

이제 사이징(sizing)을 생각해보자.
전류가 흐르는 경로를 보면, 어떤 경로(C 관련 MOSFET)는
단일 트랜지스터만 거치므로 그 길이는 1 단위이다.

하지만 A, B 관련 경로는 두 트랜지스터를 직렬로 거치므로
전류 경로가 두 배 길다.
따라서 A, B 쪽 MOSFET의 폭은 2배로 설정해야 한다.

PMOS 쪽에서도 비슷하다.
PMOS는 두 개의 분기 경로를 통해 전류를 공급하므로,
각각의 경로는 인버터보다 두 배 긴 데이터 경로를 가진다.
따라서 PMOS의 폭은 인버터 대비 4배(2×2) 로 설계해야 한다.

결과적으로 AOI 회로의 최종 폭 비율은 다음과 같이 된다:

* NMOS: W_n = [1, 2]
* PMOS: W_p = [4]

그렇다면 3입력 게이트의 경우는 어떨까?
이때는 NMOS가 세 개 직렬로 연결되므로,
전류 경로의 길이가 인버터의 3배가 된다.

따라서 NMOS의 폭을 3배로 확장해야 동일한 구동 속도를 유지할 수 있다.
반면 PMOS는 세 개가 병렬로 연결되어 있으므로,
전류 경로의 길이는 변하지 않는다.
이 경우 PMOS의 폭은 인버터 대비 2배 정도로 유지하면 된다.

이와 같은 CMOS 회로의 사이징 기법을 사용하면,
Pull-up 네트워크와 Pull-down 네트워크 간의 구동 능력을 일치시킬 수 있다.

결국 사이징은 인버터의 기준 비율을 바탕으로,
NMOS와 PMOS의 구동 강도를 동일하게 유지하는 것을 목표로 한다.

여기서 예시로 든 것처럼,
NMOS의 이동도(μₙ)가 PMOS의 이동도(μₚ)보다 약 2배 크다고 가정했지만,
이는 실제로 온도나 도핑 농도에 따라 달라질 수 있다.

좋다. 이것으로 강의 3이 끝이다.
다음 강의에서는 실제 회로 설계를 위한 프로그래밍 문법(Verilog 등) 에 대해 자세히 다룰 것이다.

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>