# ASIC 3장 정리 - 2

## 이전 강의 요약

좋다, 이전에는 논리회로 수업의 복습을 진행했다.
우선 세 가지 기본적인 불 대수(Boolean) 연산에 대해 이야기했다.
첫 번째는 AND 게이트, 두 번째는 OR 게이트, 마지막은 NOT 게이트이다.
각 논리 게이트는 이러한 기호를 사용해 표현할 수 있다.
하지만 이 논리 게이트를 실제 회로로 구현하고자 한다면, 이런 문법을 사용할 수 있다.

또한 AND, OR, NOT 게이트 외에도, 특정 기능을 설명하기 위해 배타적 논리합(XOR) 게이트를 사용할 수 있다.
하지만 XOR 게이트의 기본 연산은 AND, OR, NOT 게이트를 조합하여 표현할 수 있다.
즉, 어떤 기능이든지 세 가지 기본 연산인 AND, OR, NOT만으로 표현할 수 있다는 것이 핵심이다.

다만 이번 강의에서 배운 몇몇 다른 논리 게이트들은, 특정 기능에서 자주 사용되기 때문에 함께 다룬 것이다.
예를 들어 XOR 게이트뿐만 아니라 NAND, NOR 게이트도 그 예시이다.

또한 우리는 불 연산의 공리(axiom)와 성질(property)에 대해 살펴보았다.
가장 인상적인 부분은, 사람들이 종종 결합법칙(associative law)과 관련된 특성을 혼동한다는 점이었다.
이 외에도 여러 특성이 존재하지만, 그중 가장 중요한 것은 드모르간의 법칙(De Morgan's law) 이다.

물론 AND 게이트와 OR 게이트는 각각 곱셈과 덧셈으로 표현할 수 있다.
그러나 분배법칙(distributive law) 을 고려할 때, 
(아까 말한 결합법칙이 아니라) 중요한 부분은 분배의 특성이다.

곱셈이 덧셈에 분배되는 것은 매우 직관적이지만, 
OR 연산이 AND 연산에 분배되는 것은 일반적인 산술 연산에서는 만족되지 않기 때문에 그리 직관적이지 않다.
따라서 이 특성을 반드시 기억해야 한다.

또한 우리가 반드시 기억해야 할 가장 중요한 것은 드모르간의 법칙(De Morgan's law) 이다.
이 법칙은 논리식을 단순화할 때 매우 유용하다.

즉, 어떤 연산에서 NOT 연산이 전체에 걸쳐 있을 경우, NOT을 각 항에 분배하여 적용하면 된다.
즉, 두 입력 신호를 각각 반전시키고, 연산자도 반대로 바꾼다.
예를 들어, AND 게이트에 NOT을 씌우면 OR 게이트로 바뀌며,
OR 게이트에 NOT을 씌우면 AND 게이트로 바뀐다.

이처럼 NOT 연산을 반대로 적용한 형태를 함수의 쌍대(dual) 라고 부르기도 한다.

따라서 드모르간의 법칙을 이용하면,
NAND 연산을 두 개의 NOT 게이트와 하나의 OR 게이트의 조합으로 바꿀 수 있다.
또한 NOR 게이트는 두 개의 인버터(inverter)와 하나의 AND 게이트의 조합으로 변환할 수 있다.

그리고 우리는 불 대수의 성질을 이용한 논리 최소화(logic minimization) 예제도 다루었다.
또한 진리표(truth table) 와 항(term) 에 대한 용어도 함께 살펴보았다.

여기서 "minterm(최소항)" 이란, 출력이 1이 되는 모든 입력 조합을 하나의 곱 형태로 표현한 불 식을 의미한다.
즉, 출력이 1이 되는 입력들의 조합을 나타내는 식이다.

이러한 표현을 통해 얻은 논리식은 최소형(minimized form)은 아니지만,
주어진 진리표를 정확히 표현하는 표준형(normal form, stamdard form)이 된다.
진리표를 보면, 어떤 입력 조합에서 출력이 1이 되는지를 나열한 것임을 알 수 있다.

## Karnaugh Map

그리고 오늘 강의에서는 카르노 맵(Karnaugh Map, K-map) 에 대해 다룬다.
이를 간단히 K-맵이라고 부른다.
K-맵은 진리표(truth table)를 시각적으로 더 명확하게 표현할 수 있는 대체 도구이다.

즉, 지금까지 배운 불 대수의 성질을 이용해 함수를 단순화할 수도 있지만,
K-맵을 사용하면 훨씬 더 직관적으로 논리를 이해할 수 있다.
이 때문에 우리는 K-맵을 배우는 것이며,
K-맵을 통해 관찰된 패턴을 이용하여 논리 최소화(logic minimization) 를 수행할 수 있다.

### 2변수 K-맵

이제 여기 보이는 것은 가장 단순한 형태의 K-맵이다.
이 K-맵은 단 두 개의 변수만을 가진다.

진리표를 보면, A와 B가 모두 0이거나,
A가 1이고 B가 0일 때만 출력이 1이 된다.
이러한 진리표가 주어졌을 때, 표준형(normal form)은 다음과 같이 쓸 수 있다.

$$
F(A, B) = A'B' + AB'
$$

여기서 $ B'$ 항이 공통이므로 묶어주면, 남는 것은 $B'$ 하나뿐이다.
즉, 최종적으로 식은 단순히 $F = B'$ 로 간소화된다.
이렇게 K-맵을 이용해 표준형을 간단하게 줄일 수 있다.

그렇다면 표준형을 어떻게 간소화된 형태로 변환할 수 있을까?
이를 위해 K-맵(Karnaugh map) 을 사용한다.

K-맵은 A와 B 두 입력 값을 기준으로 표를 만든다.
각 셀은 A와 B의 조합을 이진수 형태로 표현하며,
각 위치는 출력이 1인지(논리 1), 0인지(논리 0)를 나타낸다.

예를 들어, A=1이고 B=0이라면, 이 조합은 이진수 10, 즉 십진수로 2에 해당한다.
이렇게 각 조합을 숫자로 대응시키면 K-맵의 각 칸에 어떤 값이 들어가야 하는지 쉽게 알 수 있다.

그럼 A=0, B=1인 경우는 어떨까?
이때는 이진수 01, 즉 십진수 1에 해당한다.

또한 A=1, B=1인 경우는 이진수 11, 즉 십진수 3이다.

따라서 각 칸에는 0, 1, 2, 3과 같은 작은 숫자가 표시되어 있으며,
이 숫자는 해당 셀의 십진수 인덱스를 의미한다.

진리표를 보면, 0번(00)과 2번(10) 위치에서 출력이 1이므로
K-맵의 0번 칸과 2번 칸에 논리 1(logic 1) 을 채운다.
반대로, 1번과 3번 칸은 출력이 0이므로 0으로 채운다.

결국 출력이 1인 두 칸(0번, 2번)이 논리식을 구성하게 된다.

이제 이 값을 하나로 묶을 수 있다는 점을 확인할 수 있다.
즉, 남은 단계는 해당 영역을 논리 기호로 표현하는 것이다.

이 영역은 A의 값이 무엇이든 상관없고,
단지 B가 0일 때만 출력이 1이 된다.
따라서 이 영역은 B' (B의 부정) 으로 표현된다.

이렇게 사각형 형태로 묶어 표시하면,
최종 출력 $F(A, B) = B'$ 가 된다.

이 예제는 가장 작은 크기의 K-맵을 사용한 단순한 경우이며,
이러한 K-맵은 다변수(다차원) 형태로 확장할 수도 있다.

앞서 본 예시는 2×2 형태의 K-맵, 즉 2변수 논리식이었다.
하지만 3변수, 4변수, 또는 5변수 K-맵도 가능하다.
변수가 많아질수록 K-맵은 더 많은 셀을 가지며,
각 셀은 해당 변수 조합의 출력값을 나타낸다.

따라서 주어진 진리표의 변수 개수에 따라 K-맵의 크기를 설정해야 하며,
각 셀에는 출력이 1(또는 0) 인 값을 정확히 채워 넣어야 한다.

### 3변수 K-맵

좋다. 이제 3변수 K-맵을 살펴보자.

2변수 K-맵에서는 셀의 순서가 간단히 0, 1, 2, 3으로 유지되었지만,
3변수 K-맵에서는 변수의 순서가 C, B, A 와 같이 바뀌면서 셀의 순서도 달라진다.

예를 들어,

* ( CBA = 000 ) → 십진수 0
* ( CBA = 001 ) → 십진수 1
* ( CBA = 011 ) → 십진수 3
* ( CBA = 010 ) → 십진수 2
* ( CBA = 100 ) → 십진수 4
* ( CBA = 101 ) → 십진수 5
* ( CBA = 111 ) → 십진수 7
* ( CBA = 110 ) → 십진수 6

이처럼 3변수 K-맵에서는 변수의 순서에 따라 셀의 인덱스가 달라진다.

중요한 점은, 이러한 값을 구성할 때 이진수의 변수 순서가 다를 수 있다는 것이다.
예를 들어 K-맵을 ( $A, B, C$ ) 순서로 작성할 수도 있고,
( $C, B, A$ ) 순서로 작성할 수도 있다.

예를 들어 ( $A = 1, B = 1, C = 0$ ) 이면 십진수 6이 되고,
( $A = 1, B = 1, C = 1$ ) 이면 십진수 7이 된다.

이처럼 비트 순서의 변화에 따라 셀에 대응되는 숫자도 달라진다.
하지만 두 형태 모두 올바른 표현이다.

다만 문제를 풀 때는, 이러한 순서의 차이가
논리 최소화 과정에서 결정적인 영향을 줄 수 있으므로 주의해야 한다.

물론 4변수 K-맵을 고려할 때도, 변수의 순서는 ABCD 또는 DCBA와 같이 다르게 설정할 수 있다.
이 순서에 따라 K-맵에 표시되는 숫자의 위치도 달라질 수 있다.

결국 K-맵을 완전히 이해하는 가장 좋은 방법은,
직접 예제를 풀어보며 연습하는 것이다.

이제 다음과 같은 함수를 가정해 보자.
즉, 변수의 순서는 A, B, C이며,
A는 가장 왼쪽(최상위 비트, MSB)에 있고,
C는 가장 오른쪽(최하위 비트, LSB)에 위치한다.

각 입력 조합에 따른 이진수와 십진수 값은 다음과 같다:

* 000 → 0
* 010 → 2
* 110 → 6
* 100 → 4
* 011 → 3
* 111 → 7
* 101 → 5

이제 이 조합들 중 출력이 1이 되는 경우를 기준으로 최소항(minterm) 을 작성하면,
해당 식의 최소항은 3, 5, 6, 7 이 된다.

이러한 최소항 정보를 이용하면 표준형(normal form) 을 구성할 수 있다.

예를 들어, 출력이 1인 경우가 다음과 같다고 하자:

* ( A = 0, B = 1, C = 1 ) → ( A'BC )
* ( A = 1, B = 1, C = 0 ) → ( ABC' )
* ( A = 1, B = 1, C = 1 ) → ( ABC )
* ( A = 1, B = 0, C = 1 ) → ( AB'C )

이를 모두 합하면,
$$
F = A'BC + AB'C + ABC' + ABC
$$
이 된다.
이 식이 해당 함수의 표준형(normal form) 이다.


### Minimized Form

그렇다면 이제 최소형(minimized form) 은 무엇일까?
이를 구하기 위해서는 K-맵에서 인접한 1들을 묶어 큰 사각형을 만드는 과정을 거친다.

이웃한 1들을 가능한 한 크게 묶을수록,
논리식을 더 간단하게 만들 수 있다.

이 경우, 묶은 영역은 C의 값(0 또는 1)에 영향을 받지 않으므로
C 항이 사라지고 ( A )와 ( B )만 남는다.
즉, 이 결과는 A와 B의 조합으로 표현된다.
따라서 이 영역의 논리식은 단순히 ( AB ) 형태가 된다.

이제 또 다른 경우를 보자.
이번에는 B뿐만 아니라 A까지 함께 고려해야 한다.

단, 조건은 C가 1일 때(C = 1) 만 해당된다.
따라서 C가 1일 때 출력이 1이 되려면,
( $F = C(A + B)$ ) 의 형태로 표현할 수 있다.

만약 C가 0일 때를 고려하면 ( $A'B'$ ) 와 같은 형태가 되지만,
지금 예시에서는 C=1이므로 A와 B의 합(논리합) 과 C를 곱한 형태가 최소식이 된다.

즉, 이 경우의 최소형은 ( $F = C(A + B)$ ) 이다.

### 예제 1

좋다, 그럼 다음 예제를 생각해 보자.
이 진리표의 최소항(minterm) 을 살펴보면,
출력이 1인 경우는 4, 5, 6, 7이다.

이때 0과 1은 고려되지 않으며,
출력이 1이 되는 조건은 A=1일 때이다.
즉, B의 값과는 관계없이 A가 1이면 출력이 1이다.
따라서 이 경우의 최소형은 단순히 ( F = A ) 가 된다.

이제 또 다른 예를 보자.
이번에는 4, 5, 6, 7의 네 위치에서 1이 존재하며,
각각의 위치를 묶어보면 일부 영역이 중복된다.
중복된 사각형은 생략하고, 유효한 그룹만 남기면 된다.

이제 각 그룹의 의미를 살펴보자.

* 첫 번째 그룹은 ( B = 0 ) 이고 ( C = 0 ) 인 경우 → ( B'C' )
* 두 번째 그룹은 ( A = 1 ), ( C = 1 ) 인 경우 → ( AC )

따라서 최종적으로 이 논리식은
$$
F = AC + B'C'
$$
로 단순화된다.
이것이 최소화된 형태(minimized form) 이다.

### 예제 2

그럼 또 다른 예제를 보자.
이번 K-맵에서는 네 개의 셀이 1로 표시되어 있다.
이들을 인접한 위치끼리 묶어 그룹을 만든다.

첫 번째 그룹은 ( C = 0, B = 1 ) 인 영역이므로 ( BC' ) 로 표현된다.
두 번째 그룹은 ( C = 1, A = 0 ) 인 영역이므로 ( A'C ) 로 표현된다.

따라서 최종적으로 식은 다음과 같이 단순화된다.
$$
F = A'C + BC'
$$

이처럼 K-맵의 특성을 이용하면 논리식을 매우 간단하게 줄일 수 있다.
핵심은 입력 신호의 순서를 혼동하지 않는 것과,
가능한 한 큰 영역으로 인접한 1들을 묶는 것이다.

이후 각 사각형(그룹)이 어떤 논리 조건을 나타내는지 확인하고,
그 조건을 바탕으로 최종 단순화 식을 얻으면 된다.

### 예제 3

다음 예시를 살펴보자.
이번에는 최소항(minterm) 들이 주어져 있으며,
변수의 순서는 ABCD가 아니라 DCBA 로 되어 있다.

따라서 K-맵을 작성할 때도 이 순서를 그대로 따라야 한다.
각 위치에 해당하는 출력값은 0, 1, 2, 3, 4, 5, 6, 7 등으로 표시된다.

즉, 각 셀은 ( D, C, B, A ) 순서의 이진수에 해당하는 십진수 인덱스를 가진다.
이 정보를 바탕으로 K-맵의 각 칸이 어떤 번호(입력 조합)에 대응하는지를 정할 수 있다.

이제 최소항(minterm)을 정의하자.
출력이 1인 위치는 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 등이다.

이제 이 K-맵에서 가장 큰 가능한 사각형 그룹을 그린다.
가능하다면 2×2 또는 4×2처럼 인접한 영역을 묶어
하나의 큰 블록으로 결합할 수 있다.

이렇게 하면 식을 더 단순화할 수 있으며,
중복 없이 여러 사각형으로 전체 영역을 표현할 수 있다.

이제 각 사각형이 어떤 논리 조건을 나타내는지 살펴보자.

* 첫 번째 사각형: ( A = 1, D = 0 ) → ( AD' )
* 두 번째 사각형: ( A = 1, B = 0, C = 1 ), ( D )는 무관 → ( AB'C )
* 세 번째 사각형: ( C = 0, A = 1, B = 1 ) → ( ABC' )
* 네 번째 사각형: ( D = 0, C = 0, B = 1 ), ( A )는 무관 → ( BC'D' )

따라서 최종적으로 K-맵의 최소화 식은 다음과 같다.
$$
F(D, C, B, A) = AD' + AB'C + ABC' + BC'D'
$$

물론 4차원 K-맵을 사용할 수도 있다.
하지만 변수가 많아질수록 이러한 방식은 점점 더 복잡해지고 혼동될 수 있다.
따라서 변수의 수가 많아질 경우에는,
불 대수(Boolean algebra) 의 성질을 이용하여 식을 단순화하는 것이 더 효율적이다.

## Don't Care

좋다, 이제 Don't Care(무관 상태) 에 대해 생각해보자.

Don't Care란, 해당 입력 조합에서 출력이 0이든 1이든 상관없는 경우를 의미한다.
즉, 결과에 영향을 주지 않는 입력 조합이다.

이러한 값을 나타낼 때는 K-맵이나 진리표에서 ‘X' 또는 ‘–' 기호로 표기한다.
이는 "해당 경우의 출력은 모르거나 상관없다"는 뜻이다.

따라서 진리표에서 Don't Care 항목은
0 또는 1 중 어느 쪽으로도 자유롭게 사용할 수 있다.
이를 적절히 활용하면 논리식을 더 간단하게 최소화할 수 있다.

좋다. 이제 다음과 같은 함수가 있다고 하자.
변수의 순서는 ( A, B, C, D ) 이며,
각 조합에 해당하는 이진수는 다음과 같다:
0, 1, 3, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.

이 중 출력이 1인 위치는 1, 3, 5, 7, 9번이고,
Don't Care 값(X) 은 6, 12, 13번에 존재한다.
나머지 위치는 0이다.

이제 Don't Care 항목을 포함하여
가장 큰 사각형 그룹을 K-맵에서 찾아 그려본다.
Don't Care 값은 출력이 1로 간주될 수도 있으므로
가능한 한 큰 블록을 만드는 데 활용할 수 있다.

이제 K-맵을 보면, 가장 큰 그룹은 두 개의 큰 사각형으로 묶을 수 있다.
앞서 말했듯이, Don't Care 항목(X)은 1로 취급해도 무방하므로
이를 포함하여 더 큰 사각형을 만들 수 있다.

만약 X 값이 없다면 각 항은 독립적으로 표현해야 하지만,
Don't Care가 존재하면 이를 포함하여 논리식을 더 간단히 줄일 수 있다.

이제 각각의 사각형이 의미하는 바를 살펴보자.

첫 번째 사각형은 ( A = 0 ) 이고,
( C )와 ( D )의 값은 상관없다.
따라서 이 영역은 ( A' ) 로 표현된다.

두 번째 사각형은 ( D = 1 ), ( C = 0 ) 인 영역이다.
이때 ( A )와 ( B )의 값은 무관하므로
이 영역은 ( C'D ) 로 표현할 수 있다.

따라서 최종적으로 단순화된 식은 다음과 같다:
$$
F = A' + C'D
$$

만약 Don't Care 항목을 고려하지 않고 단순히 1이 표시된 칸만으로 식을 구성한다면,
보다 복잡한 형태의 논리식이 만들어진다.
예를 들어 ( B' ) 나 추가적인 AND 연산이 필요할 수 있다.

하지만 Don't Care 값을 함께 고려하면
논리식을 훨씬 간단하게 줄일 수 있다.

### 예제 4

좋다, 이제 연습 문제를 하나 풀어보자.

다음과 같은 최소항(minterm) 들이 주어져 있다.
K-맵은 ( A,B ) 축과 ( C,D ) 축으로 나누어 작성할 수 있으며,
변수의 순서에 주의해야 한다.
(일부 순서는 논리적으로 허용되지 않는다.)

출력이 1인 위치는 3, 4, 13, 15,
Don't Care 위치는 2, 5, 6, 8, 10, 12, 14 이다.

이제 K-맵에서 가능한 한 큰 사각형 그룹을 그리고,
인접한 1과 X를 포함하여 묶는다.

묶은 결과, 다음의 영역들이 만들어진다:

* ( B = 1, C = 0 ) → ( BC' )
* ( A = 1, B = 1 ) → ( AB )
* ( A = 0, B = 0, C = 1 ) → ( A'B'C )

이 세 항을 합치면 최종식은 다음과 같다:
$$
F = A'B'C + BC' + AB
$$

### Maxterm

이제 맥스텀(maxterm) 에 대한 용어를 살펴보자.

맥스텀이란, 출력이 0이 되는 조합을 나타내는 불 식이다.
즉, 최소항(minterm)이 출력이 1인 경우를 나타낸다면,
맥스텀은 그 반대로 출력이 0인 경우를 나타낸다.

맥스텀은 덧셈(+) 대신 곱셈(·) 기호를 사용하여 표현하며,
표의 각 셀은 출력이 0인 위치를 의미한다.

예를 들어 출력이 0인 위치가 2, 4, 8, 10, 11, 14, 15라면
이 위치들이 각각 하나의 맥스텀에 해당한다.

그리고 6, 12, 13번은 Don't Care로 처리된다.
이 외의 나머지 위치는 모두 출력이 1인 경우이다.

이제 K-맵을 그려보면,
Don't Care 값을 포함해 가장 큰 사각형 두 개를 만들 수 있다.
Don't Care 항목은 포함해도 되고, 무시해도 된다.

이제 각 그룹의 의미를 살펴보면,
첫 번째 그룹은 ( A'D ),
두 번째 그룹은 ( C' ) 로 표현된다.

따라서 최종적으로 논리식은 이 두 항의 조합으로 단순화된다.

이제 최소항(minterm) 과 맥스텀(maxterm) 간의 대응 관계를 살펴보자.

최소항은 출력이 1이 되는 조합,
맥스텀은 출력이 0이 되는 조합을 각각 나타낸다.

3개의 변수를 가지는 경우를 예로 들어보자.
3비트의 조합으로는 총 8개의 가능한 입력(0~7)이 있다.
만약 3, 4, 5, 6, 7번에서 출력이 1이라면,
0, 1, 2번에서는 출력이 0이 된다.

따라서 출력이 1인 경우는 최소항으로,
출력이 0인 경우는 맥스텀으로 표현할 수 있다.

즉, minterm ↔ maxterm 변환이 가능하며,
이는 함수의 쌍대(dual) 관계로도 볼 수 있다.

좋다. 이제 질문을 하나 해보자.
우리는 지금까지 불 대수(Boolean algebra)나 K-맵을 이용하여
논리식을 단순화하는 방법을 배웠다.

## Verilog Introduction

그렇다면 이렇게 얻은 논리식을 Verilog HDL로 구현하려면 어떻게 해야 할까?

이번 강의에서는 그중 일부만 간단히 다루고,
Verilog 문법과 구조에 대한 세부 내용은 다음 강의에서 자세히 다룰 것이다.

Verilog에서 가장 먼저 해야 할 일은 모듈(module) 을 정의하는 것이다.

모듈은 C나 Python에서의 함수 정의와 유사하지만,
차이점은 이것이 하드웨어 기능 단위(Functional Hardware Block) 를 의미한다는 점이다.

따라서 하나의 모듈은 특정한 하드웨어 동작을 수행하며,
이를 정의하기 위해서는 다음 세 가지 요소가 필요하다:

1. 모듈 이름(module name)
2. 입력 및 출력 포트의 목록(port list)
3. 동작을 기술하는 내부 로직(functionality)

이 세 가지를 정의함으로써 하나의 Verilog 모듈이 완성된다.

모듈을 정의할 때는 다음과 같은 절차를 따른다.

먼저 모듈 이름을 정하고,
그 안에 입력과 출력 포트를 나열한다.
모든 포트가 정의되면 세미콜론 으로 선언부를 마무리한다.

그다음, 모듈 내부 영역에서 해당 하드웨어 블록의 기능(functionality) 을 기술하고,
마지막에는 `endmodule` 구문으로 모듈 정의를 종료한다.

물론 포트 정의는 여러 형식으로 작성할 수 있으며,
서로 다른 표현이라도 의미는 동일하다.

예를 들어,

* 두 개의 1비트 입력 포트(input port)
* 하나의 1비트 출력 포트(output port) 를 정의할 수 있다.

이때 기본 데이터 타입은 모두 `wire` 이다.
따라서 별도로 `wire`를 명시하지 않아도,
기본적으로 모든 입력·출력은 `wire` 타입으로 처리된다.

즉, 데이터 타입 선언을 생략해도 Verilog는 이를 자동으로 `wire`로 인식한다.

모듈을 정의한 뒤에는, 내부의 동작(functionality) 을 기술해야 한다.

### Verilog 예제 1

예를 들어, `and2` 라는 이름의 모듈을 작성한다고 하자.
이 모듈은 두 개의 입력을 갖는 AND 게이트를 표현한다.

입력 포트의 이름은 `in1`, `in2`,
출력 포트의 이름은 `out` 으로 한다.

```sv
module and2(
   input wire in1,
   input wire in2,

   output wire out
);
```

AND 연산은 `assign` 문을 사용하여 다음과 같이 기술할 수 있다:

```sv
assign out = in1 & in2;
```

이 식은 출력 `out`이 `in1`과 `in2`의 AND 연산 결과임을 의미한다.
모든 Verilog 문장은 세미콜론(`;`)으로 끝나야 하며,
모듈 정의의 마지막에는 반드시 `endmodule`를 작성해야 한다.

```sv
endmodule
```

물론 AND(`&`)뿐만 아니라 OR(`|`), XOR(`^`), NOT(`~`) 연산자도 사용할 수 있다.

이제 모듈을 정의했으니, 그 동작을 테스트(test) 해야 한다.
이를 위해 테스트벤치(Testbench) 를 작성한다.

테스트벤치는 Verilog에서 작성한 모듈이
의도한 대로 동작하는지 검증하기 위한 시뮬레이션용 코드이다.
즉, 테스트벤치는 실제 회로를 실행하는 대신,
입력값을 주고 출력값을 확인하는 "시험 환경"의 역할을 한다.

이 예제에서 테스트벤치는 `test`라는 이름으로 정의된다.
이 모듈은 두 입력을 갖는 AND 게이트(`and2`)를 시험하기 위한 테스트 환경이다.

테스트벤치 모듈에는 입력(`input`)이나 출력(`output`) 포트를 정의하지 않는다.
왜냐하면 외부와 연결되는 하드웨어 블록이 아니라,
단순히 시뮬레이션용 공간(testing space) 이기 때문이다.

대신 내부에서는 `reg` 타입 변수를 사용하여 입력 신호를 저장하고,
이를 통해 모듈의 동작을 시험한다.
`reg`는 임시 데이터를 저장할 수 있는 메모리 성분(memory component) 을 의미한다.


그리고 이렇게 정의한 모듈은 인스턴스화(instantiation) 하여 사용할 수 있다.
이는 C나 Python에서 함수를 호출하는 것과 비슷하다.

즉, Verilog에서 이미 정의된 모듈을 다른 모듈 내에서 불러와
입력과 출력을 연결하면 된다.

### Verilog 예제 2

예를 들어, 테스트벤치 안에서 AND 게이트 모듈을 불러올 때는
입력 `I1`, `I2`를 주고, 출력 `O`를 연결한다:

```sv
and2 my_and_gate (I1, I2, O);
```

이처럼 모듈 이름(정의된 모듈) 과
인스턴스 이름(현재 사용되는 모듈) 을 구분하여 사용한다.

앞서 말했듯이, 포트의 순서는 `in1`, `in2`, `out` 순으로 반드시 일치해야 한다.
모듈을 인스턴스화할 때는
먼저 모듈 이름(module name) 과 인스턴스 이름(instance name) 을 작성하고,
그 안에 포트들을 같은 순서로 연결해야 한다.

그다음에는 `initial` 블록을 이용하여 테스트 동작을 정의한다.
`initial` 블록은 C나 Python에서의 코드 실행 흐름과 유사하며,
안의 문장은 위에서 아래로 순차적으로 실행된다.
각 문장은 세미콜론(`;`)으로 구분된다.

먼저 `I1` 값을 초기화하고, 그다음 `I2` 값을 설정한다.
그 후 일정 시간(delay unit) 후에 결과를 출력(`$display`)하도록 한다.

각 문장이 세미콜론으로 끝나기 때문에,
코드는 순서대로 실행된다.

1. 먼저 `I1`이 실행되고,
2. 다음으로 `I2`가 실행된 후,
3. 일정 시간(`1 time unit`)을 기다린 뒤
   `$display` 명령으로 결과를 출력한다.

예를 들어 입력값이 `I1=0`, `I2=0`이라면,
AND 연산의 결과는 `O=0`이 된다.
출력은 터미널에 다음과 같이 표시된다:

```sv
I1=0, I2=0, O=0
```

그 다음 입력을 `I1=0`, `I2=1`로 바꾸면 결과는 여전히 `O=0`이다.

마지막으로 `I1=1`, `I2=1`로 변경한 뒤,
한 클럭을 기다리면 출력은 `O=1`이 된다.
즉, AND 게이트의 진리표와 동일한 결과를 확인할 수 있다.

```sv
`timescale 1ns/1ps
module test_and2;
   reg i1, i2;
   wire o;

   and2 u2(i1, i2, o);

   initial begin
      i1 = 0; i2 = 0;
      #1 $display("%b %b %b", i1, i2, o);
      i1 = 0; i2 = 1;
      #1 $display("%b %b %b", i1, i2, o);
      i1 = 1; i2 = 0;
      #1 $display("%b %b %b", i1, i2, o);
      i1 = 1; i2 = 1;
      #1 $display("%b %b %b", i1, i2, o);
   end
endmodule
```

### Verilog 예제 3

이제 또 다른 예를 보자.
만약 특정 진리표(truth table) 를 기반으로 모듈을 정의하고 싶다면,
그 진리표를 직접 코드로 표현할 수도 있다.

예를 들어, 다음은 Majority(다수결) 회로의 진리표이다.
이 회로는 세 개의 입력(A, B, C)을 받아
그 중 다수(majority)가 1이면 출력이 1이 되는 회로이다.

즉,

* 입력 중 0이 더 많으면 출력은 0,
* 입력 중 1이 더 많으면 출력은 1이 된다.

이처럼 입력값 중 다수의 상태를 출력으로 결정하는 회로가 Majority 회로이다.


이제 Majority 회로의 진리표를 바탕으로 표준형(normal form) 을 만들어보자.

출력이 1인 경우를 식으로 표현하면 다음과 같다:
$$
F = A'BC + AB'C + ABC' + ABC
$$

이 식을 단순화하면,
( $C + C' = 1$ ) 이므로 ( $AB(C + C') = AB$ ) 로 줄일 수 있다.
따라서 순차적으로 전개하면,
$$
F = AB + AC + BC
$$
가 된다.

즉, Majority 회로의 최소식(minimized form)은 다음과 같다:
$$
F = AB + AC + BC
$$

이것이 바로 Majority 모듈의 기능적 표현이다.

이제 이를 Verilog 코드로 구현해보자.

모듈 이름은 `majority` 이며,
입력 포트는 `A`, `B`, `C`, 출력 포트는 `out` 이다.
각 입력은 `input`으로, 출력은 `output`으로 정의하며,
데이터 타입은 기본적으로 `wire`이다.

최종 식은 다음과 같이 표현된다:

```sv
assign out = (A & B) | (B & C) | (A & C);
```

각 항은 AND 연산(`&`)으로 묶이고,
전체는 OR 연산(`|`)으로 결합된다.
이 식은 ( F = AB + BC + AC ) 와 동일하다.

이제 Majority 회로의 Verilog 구현 예시를 살펴보자.

앞서 정의한 `majority` 모듈이 이미 존재한다고 가정하자.
이제 해당 모듈을 테스트하기 위한 테스트벤치(testbench) 를 작성한다.

테스트벤치에는 입력·출력 포트가 따로 정의되지 않는다.
대신 내부에서 `reg` 타입을 사용해 입력 값을 저장한다.

예를 들어, 다음과 같이 선언할 수 있다:

```sv
reg [2:0] count;
```

이는 3비트 레지스터로, `count[2]`, `count[1]`, `count[0]`을 각각 나타낸다.
이 세 비트가 `majority` 모듈의 입력 A, B, C로 연결된다.

출력은 `wire` 타입으로 선언되어,
`majority` 모듈의 출력 포트(`out`)과 연결된다.

테스트벤치에서는
`majority` 모듈을 인스턴스화(instantiation) 하여 사용한다.

모듈 이름(`majority`)과 인스턴스 이름(`uut` 등)을 지정하고,
세미콜론(`;`)으로 정의를 마무리한다.

그다음 `initial` 블록 내부에 테스트 패턴을 작성한다.

1. 먼저 `count` 값을 0으로 초기화하고,
2. 8회 반복하면서 각 입력 조합(0~7)을 모두 테스트한다.

즉, `count` 값이

```
000 → 001 → 010 → 011 → 100 → 101 → 110 → 111
```
순으로 증가하며,
각 조합이 `A`, `B`, `C` 입력으로 전달된다.

그에 따른 출력(`out`)이 매 반복마다 표시된다.

```sv
`timescale 1ns/1ps
module test;
   reg [2:0] count;
   wire out;

   majority m(count[0], count[1], count[2], out);

   initial begin
      count = 3'b000;
      repeat (8) begin
         #100;
         $display("in=%b, out=%b", count, out);
         count = count + 3'b001;
      end
   end
endmodule
```

출력(`$display`)문에서는
`%b`, `%d`, `%h` 등의 형식 지정자(format specifier) 를 사용할 수 있다.

* `%b` : 값을 이진수(binary) 로 출력
* `%d` : 값을 십진수(decimal) 로 출력
* `%h` : 값을 16진수(hexadecimal) 로 출력

예를 들어 다음과 같이 작성하면:

```sv
$display("%b %b -> %b", A, B, out);
```
이 코드는 `A`, `B`, `out` 값을 이진수 형식으로 출력한다.

예를 들어 4비트 값이 `1011`이라면,
이는 이진수로 11(십진수) 을 의미한다.

이를 16진수로 표현하려면
`%h` 형식을 사용하고, 4비트 단위로 구분한다.

* 0~9는 그대로 숫자로,
* 10은 `A`, 11은 `B`, 12는 `C`, 13은 `D`, 14는 `E`, 15는 `F`로 표시된다.

따라서 `1011`은 16진수로 `B` 가 된다.
이 때문에 Verilog에서는 `%h` 형식으로 출력할 때
11을 `B`로 표현한다.

물론 Verilog에서는 숫자를 비트 폭(bit width) 과 진법(base) 을 명시하여 직접 표현할 수도 있다.
예를 들어:

```sv
4'b1011   // 4비트 이진수
8'd25     // 8비트 십진수
16'h3F2A  // 16비트 16진수
```
와 같은 방식으로 표기한다.

각 숫자는 [비트 폭]'[진법][값] 의 구조를 가진다.
이에 대한 문법적 세부사항은 다음 강의에서 더 자세히 다룰 예정이다.

지금까지 우리는 다음과 같은 내용을 다루었다.

* 불 연산(Boolean operation)의 기본 원리
* 불 대수의 주요 성질을 활용한 논리식 최소화
* 진리표(Truth Table)와 카르노 맵(K-map)을 통한 간소화 방법
* 그리고 Verilog를 이용한 기본 논리 회로 구현 방법

이제 다음 강의에서는,
최소화된 논리식을 실제 하드웨어(MOSFET 기반 회로) 로 구현하는 방법을 다룰 것이다.
즉, 논리식을 실제 트랜지스터 회로로 변환하는 과정이 다음 주제이다.

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>