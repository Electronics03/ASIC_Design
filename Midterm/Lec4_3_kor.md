# Lec4-3

## Conditional operator

이제 조건 연산자(conditional operator)에 대해 시작하겠다.
이 조건 연산자는 **assign 문**에서 자주 사용되는데, 그 이유는 **멀티플렉싱(multiplexing)** 구조를 기술하기에 매우 유용하기 때문이다.
즉, 어떤 선택 신호(selection signal)를 가지고 있을 때 — 여기서는 그것을 **expression(표현식)**이라고 부른다 — 그 표현식의 논리값이 0 또는 1일 수 있다.
만약 그 표현식이 거짓(false), 즉 논리값이 0이라면, 출력 A는 '거짓일 때의 값'을 가지게 된다.
반면 표현식이 참(true), 즉 1이라면, 출력은 '참일 때의 결과'를 가지게 된다.
따라서 조건 연산자는 "이 표현식이 참인가 거짓인가"를 판단한 뒤, 참이면 참일 때의 결과를 출력하고, 거짓이면 거짓일 때의 결과를 출력하는 것이다.
``` sv
assign A = (expression) ? true_result: false_result;
```

때때로 **동작적(behavioral) 구조**를 설계하거나, `always` 문이나 `initial` 문과 같은 **절차적 구문(procedural statement)**을 작성하고 싶을 때 `if` 문이 자주 사용된다.
그러나 이러한 **조건 연산자(conditional operator)**는 `always`나 `initial` 블록뿐 아니라, `assign` 문에서도 사용할 수 있다.
`if` 문과 다르게, 조건 연산자는 **별도의 "else if" 조건**을 가질 수는 없지만, 대신 여러 조건을 연속적으로 연결할 수 있다.
```sv
assign A =  (count==1) ? X:
            (count==2) ? Y:
            (count==3) ? Z: W;
```
예를 들어, `count`가 1이면 `X`를 출력하고, 2이면 `Y`, 3이면 `Z`, 그 외에는 `W`를 출력하도록 작성할 수 있다.
즉, 조건이 참이면 `X`가 출력되고, 거짓이면 다음 조건을 검사하며, 그 조건이 참이면 `Z`를 출력하고, 아니면 `W`를 출력한다.
이러한 방식으로, `if-else` 구조를 사용하지 않고도 조건적인 동작을 구현할 수 있다.

### Loop

Verilog 프로그램에서 코드를 더 쉽게 작성하거나 반복적인 입력을 줄이기 위해 **반복문(loop)**을 사용할 수 있다.
예를 들어, `forever` 문을 사용하면 일정한 지연(delay)마다 명령을 반복적으로 실행할 수 있다. 이는 일종의 **무한 루프**로 동작한다.
```sv
// Clock
initial begin
    clk_core = 0;
    fork
        forever #(HALF_CLK) clk_core = ~clk_core;
    join
    /*
    fork
        ...
        이 블럭은 병렬 실행을 의미하는 블럭이다.
        하지만 하나의 코드만 있으니 중요한 의미를 가지진 않는다.
    join
    */
end
```
또한 `repeat` 문을 사용할 수도 있는데, 이는 특정 횟수만큼 명령을 반복한다는 의미다.
예를 들어, 5번의 상승 에지(positive edge)를 감지한 후 해당 명령을 실행하도록 할 수 있다.
그리고 마지막 상승 에지 이후에는 다음 명령이 실행된다.
```sv
initial begin
    resetn = 1;
    #1 resetn = 0;
    repeat (5) @(posedge clk_core);
    // 5번의 posedge을 감지한 뒤 리셋이 작동한다.
    resetn = 1;
end
```
`forever`나 `repeat`뿐만 아니라, **`for` 루프**나 **`while` 루프**도 사용할 수 있는데, 주로 **테스트벤치(testbench)**나 **initial 블록**에서 사용된다.
여기서 중요한 점은 이러한 루프들은 **initial 문 안에서는 자유롭게 사용할 수 있지만**, **하드웨어 모듈 내부에서는 사용하지 말아야 한다**는 것이다.
즉, `repeat`, `while`, `forever` 같은 반복문은 **테스트용 코드(initial block)**에만 사용하라.

단, 예외적으로 `for` 루프는 **반복되는 하드웨어 인스턴스(module instance)**를 생성하는 데 사용될 수 있다.
다음 예시를 보면 확인 가능하다.
```sv
initial begin
    pe_en      = 1'b0;
    pe_first   = 1'b1;
    pe_w_is_msb = 1'b0;
    pe_ia      = 0;

    for (integer och = 0; och < O_CH; och = och + 1) begin
        pe_w[och] = 0;
    end

    repeat (200) @(posedge clk_core);
    $display("PE Operation Test!");

    for (integer t = 0; t < TEST_NUM; t = t + 1) begin
        for (integer timestep = 0; 
                        timestep < I_CH; 
                            timestep = timestep + 1) begin
            if (timestep == 0) begin
                pe_first = 1'b0;
            end
            else begin
                pe_first = 1'b1;
            end

            pe_en       = 1'b1;
            pe_w_is_msb = 1'b0;

            ia_rand0 = $random;
            ia_rand1 = $random;
            ia_rand2 = $random;
            ia_rand3 = $random;
            ia_rand4 = $random;
            ia_rand5 = $random;
            ia_rand6 = $random;
            ia_rand7 = $random;

            ia_rand_sum = $unsigned({{3{1'b0}}, ia_rand0[7:0]})
                        + $unsigned({{3{1'b0}}, ia_rand1[7:0]})
                        + $unsigned({{3{1'b0}}, ia_rand2[7:0]})
                        + $unsigned({{3{1'b0}}, ia_rand3[7:0]})
                        + $unsigned({{3{1'b0}}, ia_rand4[7:0]})
                        + $unsigned({{3{1'b0}}, ia_rand5[7:0]})
                        + $unsigned({{3{1'b0}}, ia_rand6[7:0]})
                        + $unsigned({{3{1'b0}}, ia_rand7[7:0]})
                        - 11'd1024;

            pe_ia = ia_rand_sum[10:3];

            for (integer och = 0; och < O_CH; och = och + 1) begin
                pe_w_temp[och] = $random;
                pe_w[och] = pe_w_temp[och];
            end

            @(posedge clk_core);
            if (t > 0 && timestep == 0) begin
                $display("%03d | Output: %d", t-1, $signed(pe_acc_out[0]));
                mem[t-1] = pe_acc_out[0];
            end
        end
    end
end
```
## High-level Programming Language Constructs

이제 요약하자면, 이것은 고급 프로그래밍 언어에서 사용하는 구문들과 유사한 구조이다.
Verilog에서도 `if` 문, `if-else` 문, 그리고 `case` 문을 사용할 수 있다.
이러한 구문들은 일반적인 고급 언어의 조건문과 비슷하다.
```sv
//-----------------------------
// if_statement
//-----------------------------
// Syntax
// if (<condition>) <statement>
// or
// if (<condition>) <statement>
// else <statement>

// Examples
if (set == 1)
    out = 1;

if (clear == 0)
    q = 0;
else
    q = d;
```
```sv
//-----------------------------
// case_statement
//-----------------------------
// Syntax
// case (<expression>)
//   <label1>: <statement>
//   <label2>: <statement>
//   ...
//   <labeln>: <statement>
//   default:  <statement>
// endcase

// Example
case (instruction)
    2'b00: out = a + b;
    2'b01: out = a - b;
    2'b10: out = b - a;
    default: begin
        $display("Unknown inst");
        out = 16'bx;
    end
endcase
```
하지만 **이러한 조건문들은 되도록 `initial` 블록(또는 테스트벤치)** 안에서만 사용하는 것을 권장한다.
즉, 하드웨어 모듈 내부에서 조건문을 사용할 경우에는 **단 하나의 `always` 문 안에서만** `if-else` 블록을 사용해야 한다.
같은 `always` 블록 안에서 여러 개의 `if` 블록을 반복해서 작성하면 **버그가 발생할 가능성이 높다**.
이유는 여러 가지가 있지만, 자세한 내용은 생략한다.
결론적으로, `always` 블록 하나당 **하나의 `if-else` 구조만 사용하라**는 것이다.

앞서 말한 것처럼, `forever`, `repeat`, `while`, `for` 등의 반복문은 주로 **`initial` 문 안에서** 사용된다.

## Logic Values of Verilog
그리고 이전에 설명했듯이, Verilog의 **논리값(logic value)** 은 네 가지 유형으로 나뉜다:
`0`, `1`, `Z`, `X` 이다.

* `0`은 **낮은 전압(ground)**, 즉 **논리 0**을 의미한다.
* `1`은 **높은 전압(high voltage)**, 즉 **논리 1**을 의미한다.
* `Z`는 **부동 상태(floating state)** 로, **고임피던스(high impedance)** 상태라고 부른다.
  이는 어떤 외부 드라이버도 그 신호선에 `0`이나 `1` 값을 인가하지 않고 있다는 뜻이다.
* 마지막으로, 만약 어떤 선에 `0`과 `1`이 동시에 걸리거나, 신호의 상태를 명확히 정의할 수 없는 경우,
  우리는 그것을 **'X (unknown)'**, 즉 **정의되지 않은 상태**라고 부른다.

## Number Representation in Verilog

앞서 말했듯이, 어떤 **상수(constant value)** 를 정의할 때는 10진수(decimal), 16진수(hexadecimal), 8진수(octal), 또는 2진수(binary) 형태로 정의할 수 있다.
물론 `+`와 `-` 부호도 사용할 수 있다.
하지만 **`-`(음수 부호)** 를 사용할 때는 주의해야 한다.
Verilog에서는 음수를 **2의 보수(two's complement)** 로 표현하기 때문이다.

예를 들어, 32비트 2의 보수로 표현한 값과 8비트 2의 보수로 표현한 값은 서로 다르다.
```sv
32'hFFFF_FFFF; // -1
8'hFF; // -1
```
따라서 `-` 부호를 사용할 때는 반드시 **비트 폭(bit width)** 을 명확히 지정하여,
의도한 기능(target functionality)에 맞게 동작하도록 해야 한다.


앞서 말했듯이, 숫자를 표현할 때 **밑줄(`_`) 표기법(underbar notation)** 을 사용할 수 있다.
이 밑줄은 **컴파일러나 시뮬레이터가 읽지 않으며**, 단지 사람이 코드를 보기 쉽게 **비트를 구분하는 역할**만 한다.
```sv
8'b0000_0000;
```
예를 들어, 숫자를 4비트 단위로 구분할 때 밑줄을 사용하면
각 그룹이 **LSB(하위 4비트)**, 다음 그룹이 **그다음 4비트**라는 것을 한눈에 알아보기 쉬워진다.
즉, `_` 기호는 **가독성을 위한 구분자**일 뿐, 값에는 아무 영향을 미치지 않는다.


그렇다면 다른 형태의 숫자 표현은 어떨까?
Verilog에서는 `X`와 `Z`를 숫자 표현에 사용할 수도 있다.
그러나 이러한 표현은 **특별한 경우를 제외하고는 사용하지 않는 것이 좋다.**

특히 초보자에게는 `Z`와 `X`의 사용이 어렵다.

* `Z`는 주로 **3상태 버퍼(tri-state buffer)** 를 표현할 때 사용되지만,
  초보 단계에서는 실질적으로 필요하지 않다.
* `X`는 **알 수 없는 상태(unknown state)** 를 나타내며,
  일부 조건문(`case x`) 등에서 사용할 수 있지만,
  이 값이 회로 동작에 **버그를 일으킬 수 있다.**
```sv
12'b0x0x11010zx1;
12'b0x0x_1101_0zx1;
```
따라서 초보자라면 `Z`나 `X`는 사용하지 말고,
단순히 `0`과 `1`만을 이용해 숫자 형식을 정의하는 것을 권장한다.


```sv
792;     // 32비트 정수로 간주된다.
7d9;     // 인정 안됨
'h7d9;   // 32비트 정수(32'h7d9)로 간주된다.
12'h7d9; // 12비트 정수
8'hfx;   // 8비트 정수 (음수), 8'b1111_xxxx
```
여기 몇 가지 예시가 있다.
먼저, **10진수(decimal)** 숫자를 표현할 때 **비트 폭(bit width)** 을 지정하지 않으면, 기본적으로 **32비트 정수**로 간주된다.

그리고 **16진수(hexadecimal)** 를 표현하려면 반드시 특정 표기법을 사용해야 한다.
예를 들어, `32'h7d9` 과 같이 작성해야 한다.
여기서 `32'`는 비트 폭을 의미하고, `'h`는 **16진수임을 나타내는 접두어**다.
만약 `'h`를 생략한다면, Verilog는 이 숫자를 **16진수로 인식하지 않는다.**

일반적으로 정수형(integer)은 **32비트 정밀도(precision)** 를 가진다. 
따라서 `'h7d9`에서 비트 폭을 따로 명시하지 않더라도 **기본적으로 32비트**로 해석된다.
이 예에서 `12'h7d9`는 12비트에 해당하는 16진수로 해석된다.

이 예시를 보면 왜 16진수를 사용하는지 쉽게 이해할 수 있다.
예를 들어, 12비트 값을 16진수로 표현한다고 하자.
`7`은 4비트 `0111`로, `D`는 10진수 13(`1101`), `9`는 `1001`로 표현된다.
즉, `7D9`는 이진수로 `0111_1101_1001` 이 된다.

이처럼 **16진수는 4비트 단위로 정확히 대응**되므로,
이진수와 상호 변환이 매우 간단하다.
A~F는 각각 10~15에 해당하므로, 16진수를 사용하면
**이진수보다 훨씬 간결한 표현(compact form)** 을 얻을 수 있다.

요약하자면,

* 10진수보다 변환이 간편하고,
* 2진수보다 간결하게 표현할 수 있기 때문에,
  Verilog에서는 **16진수 표현을 자주 사용한다.**

## Assignment

이제 **assignment(할당문)** 에 대해 자세히 살펴보겠다.
할당문은 게이트 간의 구체적인 연결(interconnection)을 지정하지 않고,
**조합 논리 회로(combinational logic circuit)** 를 정의하는 방법이다.
즉, 별도의 게이트 인스턴스(instantiation)를 만들지 않고,
단순히 **wire(배선)** 를 통해 신호들을 연결하여 논리 관계를 기술한다.

Verilog에서 `assign` 문을 이용해 조합 논리 회로를 설계할 때 이를 **continuous assignment(연속 할당)** 이라고 부른다.
반면, `assign` 문을 사용하지 않고 `always`, `initial`, `case`, `task`, `function` 등의 구문 안에서 값을 할당하는 것을
**procedural assignment(절차적 할당)** 이라고 한다.

이 절차적 할당은 **순차 논리 회로(sequential logic circuit)** 와 관련이 있다.
하지만 절차적 할당을 이용해서도 조합 논리 회로를 정의할 수 있다.
즉, 조합 논리는 `assign` 문(continuous assignment) 또는 procedural assignment 둘 다로 표현할 수 있다.

요약하자면,

* 조합 논리 회로는 `assign` 문으로,
* 순차 논리 회로는 `always` 문을 이용한 procedural assignment로 표현하는 것이 일반적이다.

특히 초보자에게는,
**조합 논리는 continuous assignment(`assign`)로**,
**순차 논리는 `always` + clock을 동기화한 procedural assignment로** 작성할 것을 권장한다.

여기서 여러 번 강조했듯이, **`reg` 데이터 타입**을 사용한다고 해서
실제 하드웨어 상의 **레지스터(register)** 가 사용된다는 의미는 아니다.
`reg`는 단지 컴퓨터가 코드를 **컴파일하기 쉽게 하기 위한 데이터 타입**일 뿐이다.

즉, `reg`는 단순히 **컴파일러가 이해하기 위한 문법적 정의**이며,
이것이 실제 회로에서 메모리 요소를 사용한다는 뜻은 아니다.

예를 들어, `always` 문을 사용할 때 출력 신호를 `reg` 타입으로 정의해야 하지만,
그 회로가 **조합 논리 회로**로 설계되었다면 실제로는 레지스터가 사용되지 않는다.
```sv
output reg O;
always @(A or B) begin
    O = A & B;
end
```
즉, 입력 `A`나 `B`가 변할 때마다 출력이 바로 변한다면,
이는 단순한 **조합 논리 동작**이며, **메모리 요소가 없는 회로**이다.
이 경우 `reg` 타입은 단지 문법적 표기일 뿐,
실제로는 하나의 **AND 게이트**로만 동작하고 레지스터는 존재하지 않는다.

따라서, **procedural assignment(절차적 할당)** 을 사용할 때는
출력 신호를 반드시 `reg` 타입으로 선언해야 한다.
이것은 문법상의 제약일 뿐,
조합 논리인지 순차 논리인지와는 무관하다.

반대로, 단순히 회로를 연결하거나(assign을 이용해)
게이트 간의 연결을 표현하고자 할 때는 `wire` 타입을 사용해야 한다.

정리하면 다음과 같다:

* `assign` 문 -> `wire` 타입 사용
* `always` 문(또는 initial 등 procedural block) -> `reg` 타입 사용

즉, **회로 간 연결은 `wire`**,
**동작 블록 내부의 변수는 `reg`** 로 기억하면 된다.

## Continuous Assignment

다음은 **continuous assignment(연속 할당)** 의 전형적인 예시이다.
```
assign <drive_strength> <delay> <list_of_assignments>;
```
앞서 설명했듯이, `assign` 문은 조합 논리 회로를 표현하는 데 사용된다.
이미 여러 예시를 통해 그 동작을 이해했기 때문에,
이 부분은 특별히 추가 설명이 필요하지 않다.

## Operators can be used in Continuous Assignments

### Bit-wise & Logical Operator

`assign` 문에서는 다양한 **연산자(operator)** 를 사용할 수 있다.  
이는 **연속 할당(continuous assignment)** 에서 신호 간의 연산 관계를 표현할 때 자주 사용된다.  

Verilog에서 자주 쓰이는 연산자는 다음과 같다:

| 구분 | 연산자 | 설명 |
|------|---------|------|
| **산술 연산자** | `+`, `-`, `*`, `/`, `%` | 정수형 산술 연산 (2's complement 기반) |
| **비트 연산자** | `~`, `&`, `\|`, `^`, `~^` | 각 비트 단위로 연산 수행 |
| **논리 연산자** | `&&`, `\|\|`, `!` | 전체 값을 논리적 참(1)/거짓(0)으로 평가 |
| **비교 연산자** | `==`, `!=`, `===`, `!==`, `>`, `<`, `>=`, `<=` | 두 값의 관계를 비교 |
| **시프트 연산자** | `<<`, `>>`, `<<<`, `>>>` | 비트를 왼쪽/오른쪽으로 이동 (논리/산술 시프트) |


#### 비트 연산자 (Bit-wise Operator)

비트 연산자는 **각 비트별로 독립적으로 계산**한다.  
즉, 피연산자의 **모든 비트가 개별적으로 연산 대상**이 된다.

예를 들어,  
```sv
wire [1:0] temp = 2'b10;
assign y = temp & 2'b01;
```
| temp | 2'b01 | y (`&` 연산 결과) |
| ---- | ----- | ------------- |
| 1 0  | 0 1   | 0 0           |

-> 결과: `y = 2'b00`

즉, `&`, `|`, `^` 등의 연산자는 **각 비트 쌍마다 독립적으로 계산**하며,
출력 폭은 피연산자 폭과 동일하다.

#### 논리 연산자 (Logical Operator)

논리 연산자는 **전체 피연산자를 하나의 참/거짓(boolean)** 으로 해석한다.
즉, 피연산자의 폭과 관계없이 **0이면 거짓(0), 0이 아니면 참(1)** 으로 평가한다.

예를 들어,

```sv
wire [1:0] temp = 2'b10;
assign flag = temp && 1'b1;
```
이때,
* `temp`는 0이 아니므로 “참(true)”로 간주된다.
* 따라서 `flag = 1'b1`이 된다.

| temp  | 평가값       | flag (`&& 1` 결과) |
| ----- | --------- | ---------------- |
| 2'b00 | false (0) | 0                |
| 2'b01 | true (1)  | 1                |
| 2'b10 | true (1)  | 1                |
| 2'b11 | true (1)  | 1                |

즉,
* **`&&`, `||`, `!`** 는 **1비트 결과만 반환**한다.
* **`&`, `|`, `^`** 는 **피연산자 비트폭만큼의 결과**를 반환한다.

따라서 다음의 차이를 꼭 이해해야 한다.
| 구문          | 동작                 | 결과 폭           |
| ----------- | ------------------ | -------------- |
| `temp && 1` | 전체를 참/거짓으로 평가      | 1비트            |
| `temp & 1`  | 각 비트를 독립적으로 AND 연산 | N비트 (temp와 동일) |

#### 조건문과 논리식의 사용

`if`, `case`, `while` 등의 조건문에서는
논리식(`&&`, `||`, `!`)이나 비교식(`==`, `!=`, `<`, `>`)이 자주 사용된다.

예:
```verilog
if (signal)
    out = 1'b1;
else
    out = 1'b0;
```

> **주의:**
> 여러 비트 신호를 조건식으로 사용할 경우, Verilog는 이를 **0인지 아닌지**로 판단한다.
> 따라서 논리적 의미가 명확하지 않다면, 조건식에는 **1비트 신호만** 사용하는 것이 좋다.

#### 비교 연산자 (Comparison Operators)

| 연산자                  | 의미                        | 예시        | 결과     |
| -------------------- | ------------------------- | --------- | ------ |
| `==` / `!=`          | 값이 같은지 비교                 | `a == b`  | 1 또는 0 |
| `===` / `!==`        | **X, Z 상태까지 포함하여 정확히 비교** | `a === b` | 1 또는 0 |
| `<`, `>`, `<=`, `>=` | 대소 비교                     | `a > b`   | 1 또는 0 |

예를 들어,
`4'b1x01 == 4'b1001` 은 true (X 무시)지만
`4'b1x01 === 4'b1001` 은 false (X까지 비교)이다.

#### 시프트 연산자 (Shift Operators)

| 연산자          | 종류         | 설명                          | 예시                          |
| ------------ | ---------- | --------------------------- | --------------------------- |
| `<<`, `>>`   | **논리 시프트** | 비트를 이동하고, 빈자리는 0으로 채움       | `4'b1010 >> 1 → 4'b0101`    |
| `<<<`, `>>>` | **산술 시프트** | 부호비트를 유지하면서 이동 (signed에 사용) | `4'sb1100 >>> 1 → 4'sb1110` |

즉,

* **논리 시프트**는 단순히 비트를 이동.
* **산술 시프트**는 부호(sign)를 유지하며 이동한다.

#### 정리

| 구분      | 주요 연산자                               | 반환 폭         | 의미              |
| ------- | ------------------------------------ | ------------ | --------------- |
| 비트 연산자  | `~`, `&`, `\|`, `^`, `~^` | 피연산자와 동일        | 각 비트를 독립적으로 연산 |
| 논리 연산자  | `!`, `&&`, `\|\| `               | 1비트            | 전체 값을 참/거짓으로 평가 |
| 비교 연산자  | `==`, `!=`, `===`, `!==`, `<`, `>` 등 | 1비트          | 조건 비교           |
| 시프트 연산자 | `<<`, `>>`, `<<<`, `>>>`             | 피연산자와 동일     | 비트 이동, 논리/산술 방식 |
| 조건 연산자  | `? :`                                | 피연산자에 따라 다름  | 조건에 따라 값 선택     |

### conditional operator

앞서 말했듯이, `assign` 문을 사용할 때는 절차적 할당(procedural assignment) 안에서도
조건 연산자(conditional operator)를 사용할 수 있다.
이는 **멀티플렉서(multiplexer)** 와 유사한 동작을 수행한다.

### concatenation(결합) 과 replication(반복)

또한 Verilog에서는 **concatenation(결합)** 과 **replication(반복)** 연산을 지원한다.  
이들은 신호나 비트 벡터를 재배열하거나 확장할 때 자주 사용되며,  
특히 **버스(bus) 구성**, **데이터 패킹/언패킹**, **부호 확장(sign extension)** 등에 유용하다.

#### Concatenation (결합 연산)
Concatenation은 여러 개의 비트 벡터를 **하나의 긴 벡터로 이어붙이는 연산**이다.  
이는 **중괄호 `{}`** 를 이용해 표현한다.

예를 들어, 두 개의 8비트 데이터(`word[15:8]`, `word[7:0]`)가 있을 때,  
이들을 특정 순서로 결합하여 새로운 16비트 데이터를 만들 수 있다.

```sv
wire [7:0] upper = word[15:8];
wire [7:0] lower = word[7:0];
wire [15:0] swapped = {lower, upper}; // 비트 순서 교환
```
즉,
* `[7:0]` 구간(하위 8비트)을 추출하고,
* `[15:8]` 구간(상위 8비트)을 추출한 뒤,
* 순서를 바꾸어 `{하위비트, 상위비트}` 형태로 재배치한다.

이렇게 하면 **데이터의 비트 위치를 재구성하거나 바이트 스왑(byte swap)** 하는 데 활용할 수 있다.
결합은 언제나 **왼쪽이 상위비트(MSB)**, **오른쪽이 하위비트(LSB)** 로 배치된다는 점을 기억해야 한다.

#### Replication (반복 연산)

Replication은 특정 비트 패턴을 **여러 번 반복해서 확장**하는 연산이다.
이는 **이중 중괄호 `{{}}`** 로 표현하며,
형식은 다음과 같다:

```sv
{반복횟수{비트패턴}}
```

예를 들어, 2비트 데이터 `2'b11`을 4번 반복하면:
```sv
wire [7:0] data = {4{2'b11}};  // 결과: 8'b11111111
```

즉, `2'b11` -> `11111111` 로 확장된다.
이 기능은 하드웨어적으로 **동일한 패턴을 여러 비트에 복사해 배선하는 것**과 같다.

#### Sign Extension (부호 확장)

Replication은 특히 **부호 확장(sign extension)** 에 자주 사용된다.
예를 들어, 8비트 signed 데이터(`byte`)를 16비트로 확장할 때,
최상위 비트(`byte[7]`, 즉 부호 비트)를 8번 복제하여 상위 비트를 채운다:

```verilog
wire signed [7:0]  byte  = 8'b10010101;
wire signed [15:0] word  = {{8{byte[7]}}, byte};
```

이 결과는 다음과 같다:

```
byte[7] = 1 -> 상위 8비트 = 11111111 -> word = 11111111_10010101
```

즉, 부호 비트가 1이면 음수를 유지하고, 0이면 양수를 유지하는 방식이다.
이것은 **산술적으로 동일한 값을 더 넓은 비트폭으로 확장**하는 방법이다.

#### 요약

| 구분                     | 연산자                | 기능                   | 예시                         |
| ---------------------- | ------------------ | -------------------- | -------------------------- |
| 결합 (Concatenation)     | `{}`               | 여러 벡터를 이어붙여 새 벡터 생성  | `{word[7:0], word[15:8]}`  |
| 반복 (Replication)       | `{{}}`             | 지정된 패턴을 여러 번 반복      | `{4{2'b11}} -> 8'b11111111` |
| 부호 확장 (Sign extension) | `{{n{bit}}, data}` | 상위 비트를 복제해 signed 확장 | `{{8{byte[7]}}, byte}`     |

이러한 비트 결합(`{}`)과 복제(`{{}}`) 연산은
**하드웨어 설계에서 버스 구조를 다루거나, 데이터 폭을 맞출 때 필수적인 표현 기법**이다.
특히 **모듈 간 데이터 폭이 다를 때**,
Verilog의 concatenation과 replication은 매우 직관적이고 강력한 수단이 된다.

| 구분                                        | 연산자                   | 설명                                           | 예시  |
| ------------------------------------------- | ------------------------ | -------------------------------------------- | -- |
| **2의 보수 산술 연산**                      | `+`, `-`, `*`, `/`, `%`  | 2's complement 기반 산술 연산| `a = b + c;`|
| **비트 단위 연산 (bit-wise)**               | `~`, `&`, `\|`, `^`, `~^`| 비트별 논리 연산 수행| `y = a & b;` |
| **논리 연산 (logical)**                     | `!`, `&&`, `\|\| `, `==`, `!=`, `===`, `!==`| 논리 조건 비교     | `if (a && b)` |
| **관계 연산 (relational)**                  | `>`, `<`, `>=`, `<=`     | 크기 비교 연산| `flag = (a > b);`| 
| **시프트 연산 (shift)**                     | `<<`, `>>`, `<<<`, `>>>` | `<<`, `>>` : 논리 시프트<br>`<<<`, `>>>` : 산술 시프트 | `y = a << 2;`|
| **조건 연산자 (conditional)**               | `? :`                    | 조건에 따라 두 값 중 하나 선택| `wire out = (e == 1) ? 1'b1 : 1'bz;`|
| **연결 & 반복 (concatenation / replicate)** | `{}`, `{{}}`             | 벡터 결합 및 반복 생성| `{word[7:0], word[15:8]}` -> 바이트 스왑<br>`byte = {4{2'b01}};` -> `01010101`<br>`word = {{8{byte[7]}}, byte};` -> 부호 확장 |

## Logic Values of Verilog

앞서 언급했듯이, Verilog의 논리 값에는 `0`, `1`, `Z`, `X`가 있다.
이를 도식으로 생각해보면 이해가 쉽다.

* `Z`는 외부 전압원에 의해 구동되지 않는 신호, 즉 **부동(floating)** 상태를 의미한다.
* `X`는 **값을 정확히 정의할 수 없는 상태(unknown)** 를 의미한다.

만약 논리 연산에 `X`나 `Z`가 포함되면, 결과는 다르게 나올 수 있다.
예를 들어,

* `X`나 `Z`가 `AND` 연산의 피연산자로 들어가면, 결과는 항상 `0`이 된다.
* `X`나 `Z`가 `OR` 연산의 피연산자로 들어가면, 결과는 항상 `1`이 된다.

하지만 일부 경우에는 `X`나 `Z`가 **최종 동작에 중요한 영향을 미칠 수도 있다.**
즉, `X`나 `Z`는 단순히 무시할 수 있는 값이 아니라,
회로의 불확정 동작이나 오류를 유발할 수 있는 중요한 요소다.

따라서 Verilog 코드를 작성할 때는
`X`나 `Z`와 같은 **예상치 못한 값(undesired signal)** 이 발생하지 않도록 주의해야 한다.
이러한 불확정 값들은 회로의 동작을 예측 불가능하게 만들며,
시뮬레이션 결과에 **버그**를 유발할 수 있다.

즉, `X`나 `Z` 값이 의도된 동작이 아니라면,
가능한 한 빨리 제거하여 회로의 안정성을 확보해야 한다.
Verilog에서는 모든 연산이 `0`, `1` 뿐 아니라
`X`, `Z` 상태도 포함하여 계산된다는 점을 반드시 기억해야 한다.

## Useful Boolean Operators

Verilog에는 몇 가지 유용한 논리 연산이 있다.
예를 들어, 4비트 데이터가 있다고 할 때 `~` (NOT) 연산을 적용하면
각 비트가 반전되어 결과가 출력된다.

또한, 여러 비트를 가진 데이터에 `&` (AND) 연산을 수행하면
**비트 단위의 AND 연산(bitwise AND)** 이 수행되어 최종 결과가 계산된다.
즉, 각 비트를 순서대로 비교하여 모두 1일 때만 결과가 1이 된다.
예를 들어, 입력이 `1111`이면 결과는 `1`,
입력이 `1101`이면 결과는 `0`이 된다.

논리 부정 연산(`!`) 역시 `1`을 `0`으로, `0`을 `1`로 반전시킨다.
즉, 참(`true`)은 `1`, 거짓(`false`)은 `0`으로 표현된다.
따라서 `!1`의 결과는 `0`이 된다.

결론적으로, 초보 설계자에게는 **멀티비트를 조건 연산자로 사용하는 것을 피하고**,
**단일 비트 신호를 참/거짓 판단용 조건식으로 사용하는 것**을 권장한다.

## Timescale Definition for Simulation

앞서 언급했듯이, Verilog에서는 **delay(지연)** 요소를 사용할 수 있다.
그러나 이 지연의 실제 시간 단위는 **`timescale`** 명령에 따라 달라진다.

`timescale` 지시어를 이용하면 시뮬레이션에서 사용할 **시간 단위(time unit)** 와 **해상도(time precision)** 를 정의할 수 있다.
예를 들어, `timescale 1ns / 10ps` 라고 작성하면,

* 첫 번째 값(1ns)은 **시간 단위**, 즉 `#1`이 **1ns** 임을 의미하고,
* 두 번째 값(10ps)은 **해상도**, 즉 시뮬레이터가 신호 변화를 **10ps 단위로 구분**한다는 뜻이다.

만약 `timescale 1us / 1ns` 로 변경하면,
`#1`은 1마이크로초(1µs)를 의미하고, 해상도는 1나노초가 된다.
즉, `timescale`에 따라 지연 명령(`#10`, `#100` 등)의 실제 의미가 달라지게 된다.

따라서 Verilog의 시간 지연은 **`timescale` 정의에 절대적으로 의존**한다는 점을 기억해야 한다.

`timescale` 설정에 따라 실제 `#delay` 값의 시간은 달라진다.
물론 모듈마다 서로 다른 `timescale`을 지정할 수도 있다.
그러나 일반적으로는 **테스트벤치(testbench)** 에서만 `timescale`을 지정한다.

하드웨어 모듈 내부에서는 `#delay`를 사용하지 않는다.
그 이유는 **하드웨어의 실제 지연(delay)** 은
프로세스 공정(process), 합성(synthesis), 전파 지연(propagation delay) 등에 의해 결정되며,
코드 상에서 직접 제어할 수 없기 때문이다.

따라서 `#delay` 구문은 **하드웨어 설계용이 아니라 테스트용**이다.
정리하면,

* `#delay` -> 테스트벤치에서만 사용
* `timescale` -> 테스트벤치에만 선언

하드웨어 모듈에는 `timescale`을 정의하지 말아야 한다.

## Combinational Logic Design

이제 예시를 통해 **조합 논리 회로(combinational logic circuit)** 설계를 살펴보자.
앞서 언급했듯이, 조합 논리의 특징은 **출력이 입력의 변화에 즉시 반응**한다는 점이다.

따라서 조합 논리 회로를 설계하는 가장 간단한 방법은
`assign` 문을 사용하는 것이다.
즉, **continuous assignment(연속 할당)** 만으로 조합 논리를 구현할 수 있다.

예를 들어, 다음과 같이 정의할 수 있다:

```sv
assign out = (A & B) ^ (B | C);
```

이처럼 간단한 한 줄의 `assign` 문만으로도
조합 논리 회로의 기능을 충분히 표현할 수 있다.

물론 조합 논리 회로는 `assign` 문뿐 아니라 **`always` 블록(여기서는 RACE 블록으로 표현됨)** 을 사용해서도 설계할 수 있다.
이 경우, 출력 신호는 반드시 **`reg` 타입**으로 선언되어야 하며,
`always` 문 안에서 `=` 또는 `<=`를 사용하여 값을 할당해야 한다.

예를 들어:

```sv
always @(A or B or C) begin
    out = (A & B) ^ (B | C);
end
```

위의 예에서처럼, 입력 A, B, C가 변경될 때마다 출력이 즉시 갱신된다.
만약 민감도 목록(sensitivity list)에 신호를 하나라도 빠뜨린다면
출력 값이 올바르게 갱신되지 않을 수 있으므로, 모든 입력을 반드시 포함해야 한다.

혹은 입력 목록 대신 `@(*)`를 사용할 수도 있다.
`always @(*)`는 "모든 입력이 바뀔 때마다 실행하라"는 의미로,
조합 논리 회로에서 가장 안전하고 일반적인 방식이다.

하지만 초보자에게는 `always` 블록보다 `assign` 문이 훨씬 간단하고 버그가 적다.
따라서 **조합 논리는 `assign` 문으로 표현하는 것을 권장한다.**

### Combinational Logic Design – Example (1)

이제 조합 논리 회로의 대표적인 예로 **멀티플렉서(multiplexer)** 를 살펴보자.
멀티플렉서는 선택 신호(selection signal)의 값에 따라 두 입력 중 하나를 출력으로 전달한다.

예를 들어,

* 선택 신호 `sel = 1`이면 출력은 `A`,
* 선택 신호 `sel = 0`이면 출력은 `B`가 된다.

즉,

```sv
assign out = sel ? A : B;
```

이 한 줄로 멀티플렉서의 동작을 표현할 수 있다.

물론 `always` 문을 이용해서도 멀티플렉서를 구현할 수 있다.
예를 들어:

```sv
always @(A, B, sel) begin
    if (sel)
        out = A;
    else
        out = B;
end
```

이렇게 하면 선택 신호가 1일 때는 A가, 그렇지 않을 때는 B가 출력된다.

또한, 여러 조건이 존재할 때는 **다중 조건부 할당(multiple conditional assignment)** 을 사용할 수도 있다.
예를 들어, 선택 신호가 2비트(`sel[1:0]`)라면
값이 `00`, `01`, `10`, `11`일 때 각각 다른 출력을 줄 수 있다.

이때 `if-else` 문 대신 **`case` 문**을 사용하는 것이 훨씬 가독성이 좋다.
즉, 조건이 여러 개인 조합 논리는 `case` 문으로 표현하는 것이 일반적이다.

단, `case` 문을 사용할 때 주의할 점이 있다.
먼저, **`?` 기호는 사용하지 말고**, 미정 상태를 표현할 때는 반드시 **`x`** 를 사용해야 한다.
(`?`는 Verilog에서 공식적인 와일드카드가 아니다.)

또한, 모든 입력 조건을 나열하더라도
**`default` 문을 반드시 추가하는 것이 좋다.**
모든 경우를 다 포함했다고 생각해도,
`default` 문이 없으면 일부 조건에서 회로가 불안정해질 수 있다.

예를 들어:
```verilog
case (sel)
    2'b00: out = A;
    2'b01: out = B;
    2'b10: out = C;
    2'b11: out = D;
    default: out = 2'b00; // 반드시 포함할 것
endcase
```

비록 `default`가 실행되지 않더라도,
이를 포함하지 않으면 합성 과정에서 **래치(latch)** 가 생기거나
예측 불가능한 동작을 초래할 수 있다.

따라서 초보자는 `assign` 문을,
숙련된 설계자는 `case` 문을 사용하는 것을 추천한다.


이제 구조적(structural) 설계와 비구조적(behavioral) 설계를 혼합한 예를 보자.
조합 논리 회로는 단순히 `assign` 문만으로도 정의할 수 있다.
하지만 Verilog에서는 **게이트 수준의 기본 소자(primitive cell)** 들을 직접 사용할 수도 있다.
예를 들어:

```verilog
and (out, A, B);
or  (out, A, B);
xor (out, A, B);
```

이처럼 기본 게이트를 직접 인스턴스화할 수도 있지만,
이 방식은 **가독성이 떨어지고 유지보수가 어렵다.**
따라서 초보자에게는 **`assign` 문을 이용해 논리식을 기술하는 방법**을 권장한다.

## Sequential Logic Design

이제 **순차 논리 회로(sequential logic circuit)** 설계를 살펴보자.
조합 논리 회로와 달리, 순차 논리 회로는 **시간적 동작(timing behavior)** 을 포함하므로
`assign` 문으로는 표현할 수 없다.

즉, 순차 논리에서는 `assign` 대신 반드시 **`always` 블록**을 사용해야 하며,
이때 **클록 동기화(clock synchronization)** 를 명시해야 한다.
예를 들어:

```verilog
always @(posedge clk) begin
    ...
end
```

이처럼 `posedge clk`(클록 상승 에지)나 `negedge clk`(하강 에지)를 트리거로 설정하여
회로가 클록에 따라 동작하도록 정의한다.

```sv
//----------------------------------------------
// Single always block version
//----------------------------------------------
module seq_example (
    input  clk, reset, assert_a, assert_b,
    output reg  a, b
);

always @(posedge clk)
begin
    if (~reset) begin
        a = 0;
        b = 0;
    end
    else if (assert_a) begin
        a = 1;
    end
    else if (assert_b) begin
        b = 1;
    end
end

endmodule
//----------------------------------------------
// Separate always blocks version
//----------------------------------------------
module seq_example (
    input  clk, reset, assert_a, assert_b,
    output reg  a, b
);

always @(posedge clk)
    if (~reset)
        a = 0;
    else if (assert_a)
        a = 1;

always @(posedge clk)
    if (~reset)
        b = 0;
    else if (assert_b)
        b = 1;

endmodule
//----------------------------------------------
// Different behavior when both assert_a and assert_b are high
//----------------------------------------------
```
하지만 이 예시는 좋은 예가 아니다.
그 이유는 모든 신호가 `=` 기호를 이용해 정의되어 있기 때문이다.
앞서 언급했듯이, `=` 기호(블로킹 할당, blocking assignment)는
순차 논리 회로에서도 사용할 수는 있지만, **권장되지 않는다.**

순차 회로를 설계할 때는 반드시 **`<=` 기호(논블로킹 할당, non-blocking assignment)** 를 사용하는 것이 좋다.
`<=` 기호는 실제 하드웨어의 **플립플롭(flip-flop)** 동작과 동일하게
동시에 여러 신호가 클록 에지에서 업데이트되도록 표현한다.
즉, 순차 회로를 설계할 때는 반드시 `<=`를 사용해야 한다.

## Creating a Behavioral Model of a Memory

이제 **레지스터(register)** 를 이용해 메모리 동작을 모델링할 수 있다.
예를 들어, 다음과 같이 메모리 데이터를 정의한다고 하자:

```verilog
reg [15:0] mem [0:1023];
```

이 코드는

* 각 메모리 셀의 크기를 16비트로,
* 주소 공간을 0부터 1023까지로 설정한다.

즉, **총 1024개의 주소**를 가진 **16비트 메모리 블록**이 만들어진다.
이 개념은 이후 **메모리 설계 강의**에서 더 자세히 다룰 것이다.

## Verilog Memory Load File Syntax

레지스터 배열을 이용해 메모리를 정의한 뒤에는,
**외부 파일을 읽어 초기화(initiation)** 할 수 있다.

기본적으로 Verilog에서 레지스터는 전원을 켜거나 리셋하기 전까지
정의되지 않은 상태(`X`)를 가진다.
즉, `reset` 신호가 입력되기 전에는 `mem[0]`, `mem[1]` 등의 값이 모두 `X`이다.

이때 `readmemh` 함수를 이용하면
외부의 HEX 파일(`test.hex` 등)에 저장된 값을 읽어
메모리 내용을 초기화할 수 있다.
예를 들어, `test.hex` 파일 안에

```
ABCD
FFFF
```

와 같은 값이 있다면, 시뮬레이션 시
`mem[0] = 16'hABCD`, `mem[1] = 16'hFFFF`
으로 초기화된다.

즉, 시뮬레이터가 **HEX 파일의 데이터를 메모리에 직접 로드**하는 것이다.

## Verilog System Tasks $readmemband $readmemh

이 기능은 **테스트벤치(testbench)** 에서 매우 유용하다.
칩을 테스트할 때는 항상 일정한 초기 데이터가 필요하기 때문이다.

### readmem

`$readmemb` 또는 `$readmemh` 함수를 이용하면
외부 파일로부터 데이터를 읽어 메모리에 로드할 수 있다.

* `$readmemb` -> **이진수(binary)** 파일 읽기
* `$readmemh` -> **16진수(hexadecimal)** 파일 읽기

Verilog에는 `$readmemd` 함수는 존재하지 않는다.

이 함수들은 다음과 같이 사용된다:

```verilog
$readmemh("test.hex", mem, 0, 1023);
```
`$readmemh("test.hex", mem, 0, 1023);`
이 예시에서는 `"test.hex"` 파일의 데이터를
`mem[0]`부터 `mem[1023]`까지 순서대로 읽어 초기화한다.


이제 예시를 통해 다시 정리하겠다.
다음과 같은 코드를 작성한다고 하자:

```sv
module  #(parameter accesstime = 3) sram (
    input  [9:0]  addr, // bitwith : 10
    inout  [15:0] data, // bitwith : 16
    input         ncs, noe, nwe
);

    reg [15:0] outline;
    reg [15:0] ram [0:'h3ff]; // 11자리수 2^11-1 = 2047
    // 2의 보수를 사용하므로 비트 폭을 주의해야 한다.
    // bitwith : 16
    // index   : 2048

    assign data[15:0] = (~ncs && ~noe) ? outline : 16'hzzzz;

    always @(addr, ncs, noe, nwe, data)
    begin
        #accesstime
        if (~ncs && addr <= 'h3ff)
        begin
            if (~noe)
                outline = ram[addr]; // 메모리 읽기
            else if (~nwe)
                ram[addr] = data;    // 메모리 쓰기
        end
    end
    // 이건 비동기 메모리라서 이 랙처에서는 사용하지 않는다.
endmodule

```
이 메모리는 주소 0부터 1023까지 총 1024개의 셀을 가진다.
즉, 0~1023 범위의 16비트 메모리 공간이 생성된다.

이때 `$readmemh` 또는 `$readmemb` 함수를 이용하면
해당 메모리를 외부 데이터 파일로부터 초기화할 수 있다.
이는 시뮬레이션용 **RAM 모델**로 자주 사용된다.

물론, 이렇게 정의된 메모리는 일반 변수처럼 접근할 수 있다.
예를 들어:

```sv
data_out = ram[address];
```

와 같이 데이터를 읽을 수 있다.

단, 초기화를 하지 않으면 모든 메모리 셀은 `X` 값을 가진다.
따라서 항상 `$readmemh` 또는 `$readmemb` 함수를 사용하여
시작 시점에 데이터를 로드해야 한다.

* `$readmemh`: `.hex` 파일(16진수 데이터)을 읽음
* `$readmemb`: `.bin` 파일(이진수 데이터)을 읽음

이때 `.hex` 파일을 열어보면, 각 라인에는
하나의 메모리 셀에 대응하는 16진수 값이 한 줄씩 적혀 있다.
`.bin` 파일을 사용할 경우에는 이진수 형식으로 표현된다.

```
ABCDFFFF
00AA4511
ABCDFFFF
...
```

### writememh

`$writememh`는 `$readmemh`의 반대 동작을 수행한다.
즉, 메모리의 데이터를 외부 파일로 내보내(export)어
HEX 형식의 파일을 생성할 수 있다.

예를 들어, 시뮬레이션 중에 특정 시점의 메모리 내용을 저장하고 싶다면,
다음과 같이 사용할 수 있다:

```verilog
@ (posedge clk_core);
    $display(" %03d | Output: %d", TEST_NUM-1, $signed(pe_acc_out[0]));

mem[TEST_NUM-1] = pe_acc_out[0];
$writememh("signed_acc_out.txt", mem);

```

이 명령은 `mem` 배열의 모든 값을 `output.hex` 파일로 기록한다.

각 메모리 요소는 한 줄에 하나씩 **16진수 형식**으로 저장된다.
만약 메모리 폭이 23비트라면, 각 줄마다 23비트의 값을
16진수로 변환하여 기록한다.
즉, 여러 비트를 가진 메모리의 데이터가
HEX 형태로 변환되어 파일에 저장되는 것이다.

이 기능은 시뮬레이션 결과를 파일로 분석하거나
다른 프로그램과 데이터를 교환할 때 매우 유용하다.

## Verilog Simulation Usually Do not Have Delay

Verilog 시뮬레이션에서 반드시 이해해야 할 중요한 개념이 하나 있다.
바로 **시뮬레이션 조건(simulation condition)** 과 **파형(waveform) 분석**이다.

많은 사람들이 Verilog 시뮬레이션 결과를 해석할 때
파형의 의미를 혼동하곤 한다.
시뮬레이션의 목적은 **주어진 입력에 따른 출력의 변화**를 확인하는 것이다.
입력 신호는 **시간(time scale)** 에 따라 변하고,
파형의 오른쪽으로 갈수록 시간이 흐른다는 뜻이다.

예를 들어, 다음과 같은 간단한 회로를 생각해 보자.
입력으로 `A`와 `B`가 있고,
이 두 신호를 **AND 게이트**에 통과시킨 결과가 `C`,
그리고 `C`에 **NOT 게이트**를 적용한 결과가 `D`라고 하자.

시뮬레이션 시작 시점에서 `A`, `B`, `C`, `D`는 모두 정의되지 않은 값(`X`)을 가진다.
그 후 시각 `t=10`에서 `A=1`, `B=0`으로 초기화된다고 가정한다.
이때 논리적 신호의 전파 순서는 다음과 같이 진행된다:
`A`와 `B`가 바뀌면 -> `C`가 계산되고 -> 그 결과로 `D`가 갱신된다.

입력 `A=1`, `B=0`일 때 `C=A&B=0`, 따라서 `D=~C=1`이 된다.
즉, 초기 출력 `C`와 `D`는 각각 `0`과 `1`로 바뀐다.

하지만 Verilog 시뮬레이션에서는 기본적으로 **전파 지연(propagation delay)** 을 고려하지 않는다.
따라서 실제 하드웨어에서는 `A`, `B` 변화가 게이트를 통과하는 데 시간이 걸리지만,
시뮬레이터에서는 **동시에 즉시 반영된 것처럼 보인다.**

예를 들어,

* `A=1`, `B=0`일 때 -> `C=0`, `D=1`
* `A=1`, `B=1`로 바뀌는 시점(20ns) -> `C=1`, `D=0`

이 두 변화가 시뮬레이션 상에서는 **동시에 발생하는 것처럼 보이지만**,
실제 하드웨어에서는 게이트의 지연 때문에 **약간의 순서 차이**가 존재한다.

따라서 Verilog 시뮬레이션의 파형을 보면
`C`와 `D`의 변화가 **동시에 발생**하는 것처럼 보인다.
이것이 바로 **이상적인(ideal)** 시뮬레이션의 특징이다.

이 경우 실제 전파 지연은 고려되지 않지만,
**연산 순서(order of evaluation)** 만은 유지된다.
즉,

* `A`나 `B`가 변경되면 -> `C`가 먼저 계산되고 -> `D`가 그 결과를 사용한다.

비록 두 신호가 같은 시간에 바뀐 것처럼 보이더라도,
시뮬레이터 내부에서는 **C -> D 순으로 순차적 계산**이 이루어진다.
결국 Verilog 시뮬레이션은 **지연이 0인 순차 계산 모델**로 이해하면 된다.

## Verilog Simulation Considering Delay

실제 하드웨어에서는 **전파 지연(propagation delay)** 이 존재한다.
예를 들어, 입력이 `A=1`, `B=0`에서 시작할 때,
출력 `C`는 AND 게이트의 지연 시간(예: 3ns) 후에 `0`이 된다.
그 후 `C`가 NOT 게이트를 거치면서 추가 지연(예: 2ns)을 거쳐
최종 출력 `D`가 1로 나타난다.

즉, 실제 회로에서는

* AND 게이트: 3ns
* NOT 게이트: 2ns
  총 5ns의 지연 후 결과가 나타난다.

반면 Verilog 시뮬레이션에서는
이런 **물리적 지연을 무시**하고,
**연산 순서(order)** 만 반영한다.
즉, 모든 게이트가 이상적으로 즉시 동작한다고 가정한다.

이러한 단순화는 잘못된 것이 아니다.
Verilog의 목적은 기본 논리 동작을 시뮬레이션하는 것이며,
정확한 타이밍은 **지연 요소(`#delay`)를 명시적으로 추가했을 때만** 고려된다.

## Delay Example in Initial Statement

이제 **`initial` 문**을 살펴보자.
다음 예시처럼 작성할 수 있다:

```verilog
initial begin
    A = 1'b1;
    #10 B = 1'b0;
end
```

이 코드는 다음과 같은 의미를 가진다.

* 처음에 `A`를 1로 초기화한다.
* 그 후 **10단위의 시간(delay)** 가 지난 뒤 `B`를 0으로 설정한다.

만약 `#10`이 없었다면, 두 문장은 동시에 실행되어
파형에서도 A와 B의 변화가 같은 시점에 나타났을 것이다.
즉, `#10`은 두 명령 간의 시간 간격을 지정하는 것이다.

이처럼 `initial` 문은 시뮬레이션 초기에 한 번만 실행되며,
**순차적으로(sequentially)** 동작하지만,
**지연이 없는 문장은 동시에 실행된 것처럼 보인다.**

다음 예시를 보자:

```verilog
initial begin
    A = 1'b0;
    #5  A = 1'b1;
    #10 A = 1'b0;
end
```

이 코드는 다음과 같이 동작한다.

* 시뮬레이션 시작 시(`t=0`) `A=0`
* 5ns 후(`t=5`) `A=1`
* 10ns 후(`t=15`) `A=0`

즉, 파형을 보면 A가 0 -> 1 -> 0으로 변하며,
각 변화 간의 시간 간격은 **`#` 뒤의 지연 값**에 의해 결정된다.

이러한 코드는 **테스트벤치의 신호 생성**이나
**클록 신호 시뮬레이션** 등에 자주 사용된다.
클록 신호를 생성할 때도 같은 방식으로 `initial` 문을 사용할 수 있다:

```verilog
initial begin
    clk = 1'b0;
    repeat (30) begin
        #10 clk = ~clk;
    end
end
```

이 코드는

* 처음에 `clk=0`으로 시작하고,
* 10ns마다 `clk` 값을 반전(`~clk`)시키며,
* 총 30번 반복한다.

따라서 시뮬레이션 파형에서 **주기 20ns의 클록(50MHz)** 이 생성된다.
이처럼 `repeat` 문은 간단한 클록 발생기(clock generator)로 자주 사용된다.

Verilog에서는 **여러 개의 `initial` 문**을 동시에 사용할 수 있다.
이 경우 각 `initial` 블록은 **병렬(parallel)** 로 실행된다.

예를 들어:

```verilog
initial begin
    A = 1'b0;
    #10 A = 1'b1;
end

initial begin
    B = 1'b0;
    #15 B = 1'b1;
end
```

이 코드에서는

* 첫 번째 블록이 `A` 신호를 제어하고,
* 두 번째 블록이 `B` 신호를 제어한다.

시뮬레이션에서는 두 블록이 **동시에 시작**하며,
각각 독립적인 타이밍에 따라 동작한다.
따라서 `A`는 10ns 후 1로 변하고,
`B`는 15ns 후 1로 변한다.

정리하면,

* `initial` 문 내부의 코드는 **순차적(sequential)** 으로 실행되지만,
* **여러 개의 `initial` 블록은 병렬(parallel)** 로 실행된다.


또 하나의 `initial` 블록을 추가할 수도 있다.
예를 들어:

```verilog
initial begin
    #30 $finish;
end
```

이 코드는 시뮬레이션이 30ns 동안 진행된 후 자동으로 종료되도록 한다.

즉, 여러 개의 `initial` 블록을 동시에 사용할 수 있으며,
각각의 블록은 병렬(parallel)로 실행된다.
하지만 **한 블록 내부의 문장들은 순차적(sequential)** 으로 실행된다.
따라서 `initial` 문은

* **내부는 순차 실행**,
* **블록 간에는 병렬 실행**
  이라는 두 가지 특성을 가진다.

다음 예시를 보자:

```verilog
initial begin
    A = 5;
    B = 2;
    #3 A = 8;
    #20 $finish;
end
```

이 코드는 다음과 같은 의미를 가진다.

* 시뮬레이션 시작 시점에 `A=5`, `B=2`로 초기화된다.
* 3ns가 지난 후 `A=8`로 변경된다.
* 그 후 20ns 동안 대기하고 시뮬레이션을 종료한다.

즉, 시간 흐름에 따라 A는 0ns에서 5, 3ns에서 8로 변하며,
B는 계속 2로 유지된다.
이처럼 `#delay`는 **명령 간의 시간적 간격**을 제어하는 역할을 한다.

## BlockingAssignments in 'initial' or 'always'

이제 **blocking assignment(블로킹 할당)** 과
**non-blocking assignment(논블로킹 할당)** 의 차이를 비교해보자.

`=` 기호를 사용한 할당은 **blocking assignment**,
`<=` 기호를 사용한 할당은 **non-blocking assignment** 라고 부른다.

두 문법 모두 `always` 또는 `initial` 블록 안에서 사용되며,
문장이 실행되는 순서와 동작 방식에 큰 차이를 만든다.
다음 예제에서 그 차이를 살펴보자.

**blocking assignment (`=`)** 은 `always` 또는 `initial` 문 안에서
**순차적으로(sequentially)** 실행된다.

예를 들어, 16비트 신호 `word`가 있다고 하자:

```sv
word = 16'b1111111100000000;
```

이 상태에서 다음과 같은 코드가 실행된다고 하자:

```sv
always @(posedge clk) begin
    word[15:8] = word[7:0];
    word[7:0]  = word[15:8];
end
```
이 코드는 순서대로 실행되기 때문에,
첫 번째 문장이 실행된 후 `word[15:8]`에는 `00000000`이 저장된다.
그다음 두 번째 문장이 실행될 때, 이미 덮어써진 값이 사용되어
결과적으로 `word` 전체가 `0000_0000_0000_0000`이 된다.

즉, **blocking assignment** 는
한 줄이 끝난 후 다음 줄이 실행되므로
중간 상태가 다음 문장에 영향을 미친다.
이 때문에 **의도한 바이트 교환(swap)** 이 제대로 일어나지 않는다.

```sv
always @(posedge clk) begin
    word[7:0] = word[15:8];
    word[15:8]  = word[7:0];
end
```
즉, 위와 같은 방식으로 코드를 작성하면
**바이트가 교환(swap)** 되지 않는다.
첫 번째 명령에서 `MSB(상위 바이트)` 값을 `LSB(하위 바이트)`에 복사하고,
그다음 명령에서 동일한 값으로 `MSB`를 다시 덮어쓰기 때문이다.
결과적으로 `word` 전체가 `1111_1111_1111_1111`이 된다.

이처럼 **blocking assignment** 는 한 문장이 완전히 끝난 뒤 다음 문장이 실행되므로
중간 결과가 이후 문장에 직접 영향을 미친다.
따라서 신호 간 데이터 교환처럼 동시에 일어나야 하는 연산에는 적합하지 않다.

## Non-BlockingAssignments in 'initial' or 'always'

이제 **non-blocking assignment (`<=`)** 를 보자.
다음 예시와 같이 동일한 코드를 `<=`로 바꾸면:

```sv
word[15:8] <= word[7:0];
word[7:0]  <= word[15:8];
```

이 두 문장은 **동시에 실행**된다.

즉,
* `MSB`에는 이전의 `LSB` 값이 저장되고,
* `LSB`에는 이전의 `MSB` 값이 저장된다.
그 결과 바이트가 정확히 **서로 교환(swap)** 된다.

따라서 non-blocking 할당은 **모든 오른쪽 값(RHS)** 을
먼저 평가한 뒤, **모든 왼쪽 값(LHS)** 을 동시에 갱신한다.
이 때문에 실제 하드웨어의 동작(플립플롭 동기화)과 동일하다.
결론적으로, `<=`를 사용하면 올바르게 `FF00 -> 00FF`로 바이트가 교환된다.

## Sequential Procedural Assignments in 'always'

**blocking assignment(`=`)** 과 **non-blocking assignment(`<=`)** 의 핵심 차이는 실행 순서에 있다.

* **blocking assignment**: 명령이 **순차적(sequential)** 으로 실행된다.
* **non-blocking assignment**: 명령이 **동시에(parallel)** 실행된다.

다음 예시를 보자:

```sv
always @(posedge clk) begin
    A = 1;
    B = A + 1;
end
```

이 코드는 blocking assignment를 사용하므로,
`A=1`이 먼저 실행된 후 `B=A+1`이 수행된다.
따라서 `B`는 항상 `2`가 된다.

반면 non-blocking assignment로 바꾸면:

```sv
always @(posedge clk) begin
    A <= 1;
    B <= A + 1;
end
```

이 경우 `A`와 `B`는 동시에 갱신된다.
즉, `B`는 이전 클록 주기의 `A` 값을 참조하므로
한 주기 뒤에 반영된다.

이처럼 **non-blocking assignment는 레지스터 동작(동기화된 갱신)** 을 정확히 모델링**하며**,
**blocking assignment는 단순 순차 연산(즉시 갱신)** 을 모델링한다.

많은 학생들이 **blocking(`=`)** 과 **non-blocking(`<=`)** 의 차이를 혼동한다.
그래서 다음과 같이 정리하면 이해하기 쉽다.

* **조합 논리(combinational logic)** 를 설계할 때는 `=` 기호를 사용하라.
  (즉, `always @(*)` 나 `initial` 문에서는 `=` 사용)
* **순차 논리(sequential logic)** 를 설계할 때는 `<=` 기호를 사용하라.
  (즉, `always @(posedge clk)` 와 같이 클록 동기화된 블록에서는 `<=` 사용)

이 규칙만 지켜도 대부분의 혼동을 피할 수 있다.
결론적으로,

* `=` -> 순서대로 실행되는 **즉시 갱신(Blocking)**
* `<=` -> 동시에 실행되는 **동기 갱신(Non-blocking)**
  이다.

다음 예로 차이를 시각적으로 이해해보자.

#### (1) Blocking Assignment (`=`)

```verilog
always @(posedge clk) begin
    Y1 = in;
    Y2 = Y1;
end
```

이 코드는 다음과 같이 동작한다.

* 클록 상승 에지에서 `Y1`이 `in`으로 즉시 갱신된다.
* 그다음 `Y2`가 `Y1`의 **새로운 값(in)** 을 복사한다.

따라서 실제 하드웨어에서는 **두 레지스터가 동일한 값을 가지게 된다.**

#### (2) Non-blocking Assignment (`<=`)

```verilog
always @(posedge clk) begin
    Y1 <= in;
    Y2 <= Y1;
end
```

이 경우 두 문장은 동시에 실행된다.

* `Y1`은 입력 `in`을 받고,
* `Y2`는 **이전 클록 주기의 Y1 값**을 받는다.

즉, **파이프라인 구조**처럼 1클록 지연된 데이터 전달이 구현된다.

결국 `=`과 `<=`의 선택은 **하드웨어 구조 자체를 바꾸는 결정적 요소**가 된다.
잘못 사용하면 회로의 동작이 완전히 달라질 수 있다.



다음은 **blocking(`=`)** 과 **non-blocking(`<=`)** 을 섞어서 썼을 때의 문제를 보여주는 예다.

```sv
always @(posedge clk) begin
    A = 3;
    A = 4;
    A = 5;
    B = A; #5;
end
```
```sv
always @(posedge clk) begin
    A = 3;
    A = 4;
    A = 5; // 이게 끝난 다음
    B <= A; #5; // 이게 실행
end
```
이 경우 순서대로 실행되므로
`A=5`, `B=5`가 된다.

하지만 다음처럼 섞어서 사용하면 문제가 생긴다.
```sv
always @(posedge clk) begin
    A = 3;
    A = 4;
    B = A;
    A = 5; #5;
end
```
```sv
always @(posedge clk) begin
    A = 3;
    A = 4;
    B <= A;
    A = 5; #5;
end
```
이 경우 `B`는 **이전 클록의 A값(4)** 을 받게 되고,
`A`는 클록 에지에서 5로 갱신된다.
결과적으로 `A=5`, `B=4`가 된다.

이처럼 두 문법을 혼용하면 **예측 불가능한 타이밍 문제**가 발생한다.
따라서 한 블록 안에서는
`=`과 `<=` 중 **하나만 일관되게 사용해야 한다.**

따라서 Verilog 설계 시
**`=`(blocking)** 과 **`<=`(non-blocking)** 을 **섞어 사용하는 것은 절대 금지**다.
이는 회로의 타이밍과 구조를 완전히 바꾸어
심각한 오류를 유발할 수 있다.

이것으로 이번 강의에서 다룬 Verilog 문법 설명을 마친다.
강의에서 제시된 예제들과 교재의 연습 문제를 통해
직접 코드를 작성하고 시뮬레이션을 해보길 바란다.
직접 실습하면서 문법과 회로 동작의 차이를 익히는 것이 가장 중요하다.

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>