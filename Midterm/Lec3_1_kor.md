# ASIC 3장 정리 - 1

지금까지 우리는 ASIC 설계 혹은 회로 설계의 전체적인 과정을 이야기했는데,
이제 논리회로 수업에서 다뤘던 몇 가지 내용을 간단히 복습하고,
그 후에 병렬 프로그래밍 방법론과 조합 논리 회로 및 순차 논리 회로의 세부 사항을 계속 다루겠다.

오늘 강의는 두 부분으로 나뉜다.
첫 번째 부분은 논리 최소화(logic minimization)에 관한 것이고,
두 번째 부분은 실제 논리 회로 구현에 관한 것이다.
먼저, 논리 게이트의 기본 동작과 논리 연산이 무엇인지 살펴본 뒤,
K-map(카르노 맵)을 이용한 논리 최소화 방법을 다룰 것이다.
그 후에는, 최소화된 논리 연산을 CMOS 기술을 이용하여
AND 게이트나 NOT 게이트로 구성된 실제 회로로 변환하는 과정을 살펴볼 것이다.

CMOS는 NFET과 PFET 두 소자로 구성된다.
좋다, 이제 불 대수(Boolean algebra)에 대해 이야기해보자.
불 대수의 정의는 논리값에 대한 연산을 다루는 수학의 한 분야이다.

## Introduction of Logical Values

논리값(logical value)이란 무엇인가?
그 값은 0, 1, x, z가 될 수 있다.
0과 1의 의미는 직관적으로 알 수 있다.
그렇다면 x는 무엇인가?
이는 정의할 수 없는 값, 즉 정확히 알 수 없는 상태(불명확 상태)를 의미한다.

이런 모호한 상태(ambiguous status)는 어떤 경우에 생길까?
이걸 이해하기 위해, 인버터(inverter)를 만들 때 사용하는 NFET과 PFET 두 개의 트랜지스터를 생각해보자.
이제 서브라인(subline)에 1.0V의 전압이 인가된다고 가정하자.
일반적으로 입력 전압이 높을 때 (예: 1.0V),
아래쪽 NFET은 켜지고, 위쪽 PFET은 꺼지며,
결과적으로 출력선(output wire)은 0.0V, 즉 접지(GND)에 연결된다.

반대로, 입력을 0V(접지)로 연결하면,
NFET은 꺼지고, PFET은 켜지게 된다.
이 경우 출력은 1.0V가 되어 출력이 "상승(up)"된 상태가 된다.

하지만 입력 전압이 0.5V처럼 중간값일 경우엔 어떨까?
이때는 NFET과 PFET이 모두 부분적으로 켜진다(partially on).
결과적으로 출력 전압이 정확히 얼마가 될지 예측할 수 없다.
즉, 이 상태는 불명확한 전압 상태가 된다.

물론 이 출력이 0V 또는 1V 중 하나로 수렴할 것임은 예상할 수 있다.
그러나 그 순간에는 어떤 값이 될지 확실히 알 수 없다.
왜냐하면 그 값은 NFET과 PFET의 구동 세기(driving strength)에 따라 달라질 수 있기 때문이다.
또한 이 구동 세기는 온도(thermal energy)에 따라 변하기도 한다.
즉, 온도가 변하면 트랜지스터의 동작 특성도 달라지게 된다.

이런 요인들 때문에, 이 경우의 출력값은 쉽게 예측할 수 없다.
따라서 우리는 이러한 출력을 'x'로 표기하며,
이를 모호한 값(ambiguous value), 정의되지 않은 값(undefined value), 또는 알 수 없는 값이라고 부른다.

실제 회로 실행에서는 결국 0V 또는 1V 중 하나의 값을 갖게 되지만,
시뮬레이션 단계, 특히 Verilog 시뮬레이션에서는
그 값이 확정되지 않기 때문에 'x'로 표시된다.
> 둘 중 하나로 수렴하는 것은 맞지만,
그게 어느 값인 지는 알 수 없으므로 X로 표기한다

그렇다면 'Z' 값은 무엇일까?
Z 값은 다음과 같은 경우를 뜻한다.
두 개의 MOSFET을 스위치처럼 사용한다고 하자.
하나는 VDD(1.0V)에 연결되어 있고, 다른 하나는 GND(0.0V)에 연결되어 있다.
만약 A MOSFET이 켜져 있다면, 출력은 1.0V가 된다.
반대로 A를 끄고 B를 켠다면, 출력은 0.0V가 된다.
즉, 두 스위치(A, B)의 상태에 따라 출력이 결정된다.

앞서 말했듯이, 두 MOSFET을 모두 켜면,
출력은 어떤 값이 될지 알 수 없기 때문에 'X' 상태가 된다.
그런데 반대로 두 MOSFET을 모두 끄면,
출력에 전압을 공급하는 구동원(driving source)이 전혀 없게 된다.

A가 켜지면 1.0V가 출력으로 전달되고,
B가 켜지면 0.0V가 출력으로 전달된다.
하지만 두 연결이 모두 끊어져 있으면,
출력으로 전압을 공급하는 소스가 없기 때문에,
출력 전압은 정의되지 않는다.
> 어떠한 Source와도 연결되어있지 않은 상태이다.

실제 회로 실행 시에는,
이 출력이 이전에 저장된 값(previous output value)을 유지할 수도 있다.
예를 들어, 직전에 1.0V가 출력되었다가 스위치가 꺼졌다면,
잠시 동안은 1.0V 상태가 유지된다.
하지만 시간이 지나면 주변 회로의 전류 손실(current loss) 때문에
그 전압이 점차 0.0V로 떨어지게 된다.

따라서 'Z'의 핵심 의미는 다음과 같다.
다른 논리값(0, 1, X)과 달리, 출력을 구동하는 소스가 전혀 없는 상태라는 것이다.
즉, 고임피던스 상태(High Impedance State)를 의미한다.
> 스위치가 닫혀있어 신호가 Source 단으로 전달되지 않음.
Mosfet 구동 특성상 꺼져있으면 High Imp이므로 이걸 Z로 표기하는 것임.
이러한 특성은 버스 설계에서 inout port 에 사용 가능
출력이거나 입력일때는 신호를 받고, 다른 신호 구동이 있는 경우에는 Z로 바꾸어,
신호가 들어오지 않도록 함.

다음으로, 두 MOSFET을 스위치처럼 사용하는 3상(tri-state) 버퍼를 보자. 이 구조에서는 두 스위치를 모두 켜면 상·하단이 동시에 구동되어 충돌이 발생하고 시뮬레이션에서는 X로 나타난다. 두 스위치를 모두 끄면 출력에 구동원이 없어 Z(고임피던스) 상태가 된다.

## Boolean Algebra - 기본 Gates

아무튼, 불 대수(Boolean algebra)는
이러한 논리값들(0, 1, X, Z)을 이용하여 연산을 수행하는 수학이다.
이 값들은 이진 변수(binary variable)로 표현된다.

그렇다면 불 대수에서 주로 사용되는 기본 연산은 무엇일까?
가장 대표적인 세 가지 연산이 있다.
1. AND (논리곱),
2. OR (논리합),
3. NOT (부정) 연산이다.

식을 쓸 때는 각 연산마다 다른 기호(symbol)를 사용한다.
예를 들어,

* A와 B 사이에 점(·)을 찍으면 AND 연산,
* 더하기(+) 기호를 쓰면 OR 연산,
* 위에 bar(―)를 씌우면 NOT 연산을 의미한다.

그러나 Verilog 프로그래밍에서는 이와 다른 기호를 사용한다.

* `&` 기호를 사용하면 AND 연산을,
* `|` 기호를 사용하면 OR 연산을,
* `~` 기호를 사용하면 NOT 연산을 표현할 수 있다. 즉, 이러한 기호들을 통해 Verilog에서 논리 연산을 실제로 구현할 수 있다.

### AND
이제 논리 게이트의 회로 기호(symbol)를 보자.
AND 게이트는 왼쪽이 평평하고 오른쪽이 둥근 반원형 구조를 가진다.
두 개의 입력선을 받아 하나의 출력을 내보낸다.
출력은 A와 B 두 입력이 모두 1일 때만 1이 된다.
### OR
다음은 OR 게이트이다.
OR 게이트는 부드럽게 휘어진 곡선형 구조를 가지며, 두 입력을 받아 출력을 만든다.
A나 B 중 하나라도 1이면 출력은 1이 된다.
### NOT
NOT 게이트(인버터)는 삼각형(triangle) 모양에 끝에 동그라미(bubble)가 붙은 형태이다.
삼각형만 있을 경우는 버퍼(buffer)라고 부르지만,
끝에 버블(bubble)이 붙으면 NOT 게이트로 인식된다.
이 게이트는 입력의 논리값을 반전(invert)시켜 출력한다.
따라서 입력이 0이면 출력은 1,
입력이 1이면 출력은 0이 된다.

### Verilog로 구현

이러한 논리 연산을 Verilog로 구현하려면 다음과 같이 정의해야 한다.
A와 B는 1비트 입력 신호로 선언하고,
출력은 각각 AND, OR, NOT 연산 결과를 표현하도록 한다.

```sv
module basic_logic(
	input A,
	input B,

	output out_and,
	output out_or,
	output out_not
);
	...
endmodule
```

물론 신호 이름은 자유롭게 바꿀 수 있다.
이 연산들은 Verilog의 `assign` 구문을 통해 구현한다.
예를 들어,

```sv
assign out_and = A & B;
assign out_or  = A | B;
assign out_not = ~A;
```
이렇게 작성하면 각각 AND, OR, NOT 연산이 정의된다.
각 문장은 반드시 세미콜론(`;`)으로 끝나야 한다.

### XOR
이 외에도 다른 논리 게이트가 있다.
그중 하나가 XOR (Exclusive OR) 게이트이다.
XOR 게이트의 기호는 OR 기호에 '+' 모양이 추가된 형태이다 $\oplus$.
XOR의 의미는 "두 입력 중 하나만 1일 때 출력이 1이 된다"는 것이다.

여기서 볼 수 있듯이,
A와 B가 둘 다 0이거나 둘 다 1이면 출력은 0이 된다.
반면, A만 1이거나 B만 1인 경우에는 출력이 1이 된다.
이것이 XOR 연산의 기본 동작이다.

다시 말해 이렇게 표현할 수 있다.

* A와 B가 같으면 출력은 0,
* A와 B가 다르면 출력은 1이다.

즉, XOR은 "입력이 서로 다를 때 1을 출력하는 연산"이다.

이제 이 XOR 연산을 기본 게이트로 구현해보자.
진리표를 보면, 출력이 1이 되는 경우는

* A가 0이고 B가 1인 경우,
* A가 1이고 B가 0인 경우이다. 따라서 출력 F는 다음과 같이 표현된다.
$$
F = (\overline{A}B) + (A\overline{B})
$$

따라서 두 조건을 OR 연산(+)으로 합치면,
XOR의 전체 식은
$$
F = (\overline{A}B) + (A\overline{B})
$$
이 된다.
즉, AND, OR, NOT 게이트만으로 XOR 게이트를 구성할 수 있다.

이 논리식을 회로 기호(symbol)로 나타내면,
두 개의 AND 게이트, 하나의 OR 게이트, 그리고 두 개의 NOT 게이트가 필요하다.
이 회로는 앞서 식에서 사용한 연산을 그대로 구현한 것이다.
또한 XOR 게이트는 디지털 회로 설계에서 매우 자주 사용되는 기본 게이트이다.

따라서 XOR 연산의 실제 동작을 이런 회로 형태로 나타낼 수 있다.
앞서 말했듯이, NOT 게이트(인버터)는
꼭 삼각형+버블 형태가 아니라,
버블(bubble) 기호 하나로도 표현할 수 있다.
그래서 회로도에서 두 가지 형태 모두 사용이 가능하다.
```sv
module XOR(
	input A,
	input B,

	output out_xor,
	output out_xor_AOI
);
	assign out_xor = A ^ B;
	assign out_xor_AOI = (A&(~B))|((~A)&B);
endmodule
```
### NAND
XOR 외에도 또 다른 논리 게이트들이 있다.
그중 하나는 NAND 게이트이다.
NAND 게이트는 AND 게이트 + NOT 게이트의 조합으로 구성된다.

예를 들어, AND 게이트의 진리표에서
입력 A, B가 (00, 01, 10, 11)일 때 출력은 (0, 0, 0, 1)이다.
하지만 NAND 게이트는 AND 결과에 NOT 연산을 적용하기 때문에
출력은 (1, 1, 1, 0)이 된다.
즉, AND의 반대 동작을 수행한다.

### NOR
이제 NOR 게이트를 보자.
OR 게이트의 진리표는 입력이 (00, 01, 10, 11)일 때 출력이 (0, 1, 1, 1)이다.
그러나 NOR 게이트는 OR의 반대이므로, 출력은 (1, 0, 0, 0)이 된다.
즉, OR의 부정(反)을 의미한다.

이것이 NAND와 NOR 게이트의 의미이다.
이 두 게이트는 각각 AND 또는 OR 게이트 뒤에 NOT을 추가함으로써 구현할 수 있다.
물론 AND 게이트와 NOT 게이트를 따로 연결해 표현할 수도 있지만,
앞서 말했듯이 NOT 연산은 버블(bubble)로도 표현할 수 있다.
따라서 회로 기호는 여러 가지 형태로 나타낼 수 있다.

마찬가지로 NOR 게이트도 OR 게이트 뒤에 버블을 붙여 표현할 수 있다.
즉, 기본 OR 게이트의 출력에 버블을 추가하면 NOR 게이트가 된다.
이와 같이 게이트 형태를 바꾸는 방법은 나중에 자세히 다룰 예정이다.
그 원리를 이해하려면 드모르간의 법칙(De Morgan's Law)을 알아야 한다.

즉, NAND나 NOR 연산을 직접 나타내려면
별도의 새로운 게이트가 필요한 게 아니라,
AND+NOT, OR+NOT의 조합으로 표현하면 된다.

XOR 게이트의 경우는 이미 설명했기 때문에 생략하겠다.
XOR은 앞서 보여준 기호 하나로도 직접 표현할 수 있으며,
Verilog에서도 별도의 복잡한 구현 없이
단순히 `^` 연산자를 사용하면 된다.

### XNOR
지금까지 여러 논리 게이트의 기호(symbol)를 살펴보았다.
유일하게 다루지 않은 것은 XNOR 게이트이다.
왜냐하면 XNOR은 단순히 XOR 게이트 + NOT 게이트의 조합으로 표현되기 때문이다.

따라서 XNOR의 경우,
입력이 0이면 출력은 1,
입력이 1이면 출력은 0이 된다.
즉, XOR의 결과를 반전(invert)한 값이 XNOR의 출력이다.

정리하자면,
XOR은 A와 B가 다를 때 1을 출력하지만,
XNOR은 A와 B가 같을 때 1을 출력한다.
따라서 두 게이트는 서로 반대 관계에 있다.

또한 앞서 배운 여러 논리 연산의 성질과 특성은
곧 다룰 논리 최소화(logic minimization)를 이해하는 데 매우 중요하다.
따라서 이러한 기본 특성들을 스스로 확실히 이해해야 한다.

## Boolean Algebra - 특성들

이제 그 성질들을 하나씩 살펴보자.

먼저, AND 연산에서 어떤 값에 1을 곱하면 원래 값이 그대로 유지된다.
즉,
$$
X \cdot 1 = X
$$
이다. AND에서 1은 항등원이라 결과에 영향을 주지 않는다.

반대로 OR 연산에서는 어떤 값에 1을 더하면 결과는 항상 1이 된다.
즉,
$$
X + 1 = 1, \quad
X + 0 = X
$$
이다. OR에서 0은 항등원이다.

그렇다면 AND 연산에서 0을 사용하면 어떨까?
어떤 값이든 0과 AND를 하면 결과는 항상 0이다.
한편 OR 연산에서 1을 사용하면 결과는 항상 1이다.
이것이 불 대수의 가장 기본적인 항등(Identity)/영원(Annihilation) 성질이다.

부정(negation)은 NOT 연산을 의미한다.
즉,
$$
\overline{0}=1, \quad
\overline{1}=0
$$

다음은 교환법칙(commutative law)이다.
AND와 OR 연산은 순서를 바꾸어도 결과가 동일하다.
$$
A \cdot B = B \cdot A, \quad
A + B = B + A
$$

결합법칙(associative law)도 성립한다.
AND나 OR를 여러 번 수행할 때 묶는 순서와 무관하게 결과는 같다.
$$
(A \cdot B) \cdot C = A \cdot (B \cdot C)
, \quad
(A + B) + C = A + (B + C)
$$

분배법칙(distributive law)도 성립한다.
예를 들어,
$$
X \cdot (Y + Z) = (X \cdot Y) + (X \cdot Z)
$$
처럼 AND가 OR에 대해 분배된다.
불 대수에서는 이와 반대로 OR가 AND에 대해서도 분배된다.
$$
X + (Y \cdot Z) = (X + Y)\cdot(X + Z)
$$
즉, 일반적인 산술에서 "덧셈이 곱셈에 분배되지 않는 것"과 달리, 불 대수에서는 AND와 OR가 서로에 대해 모두 분배 가능하다는 점이 특징이다.

같은 항이 반복되어도 결과는 바뀌지 않는다(멱등법칙, idempotent).
$$
X + X = X, \quad
X \cdot X = X
$$

또한 보수(complement)에 대한 기본 성질이 있다.
$$
X \cdot \overline{X} = 0, \quad
X + \overline{X} = 1
$$

흡수법칙(absorption law)에 따르면,
$$
X \cdot (X + Y) = X,
\qquad
X + (X \cdot Y) = X
$$
이다. 벤 다이어그램(Venn diagram)으로 보면 $(X+Y)$는 $X$를 포함하므로, $X$와 AND를 취하면 다시 $X$가 된다. OR의 경우에도 $X$가 이미 포함되어 있으므로 결과는 $X$ 그대로다.

결합(또는 결합 성질/combining property)도 자주 쓰인다.
$$
(X \cdot Y) + (X \cdot \overline{Y}) = X
$$
여기서 $Y + \overline{Y} = 1$이므로, 전체가 결국 $X$와 같다. 즉, 모든 경우($Y$이든 $\overline{Y}$이든)를 포함하므로 $X$ 하나로 단순화된다.

가장 중요한 성질 중 하나는 드모르간의 법칙(De Morgan's law)이다.
이것은 뒤에서 자세히 다루겠다.

마지막으로, AND와 OR는 논리기호뿐 아니라 곱셈(·)과 덧셈(+) 기호로도 표현한다.
AND는 곱셈과 유사하게, OR는 덧셈과 유사하게 다루지만, 실제 산술과는 몇 가지 차이가 있다. 예를 들어 불 대수에서는
$$
X + X = X
$$
처럼 중복 항이 단일 항으로 단순화된다(산술의 $X+X=2X$와 다르다). 또한 앞서 보았듯 불 대수에서는 AND와 OR가 서로에 대해 분배 가능하다는 점이 중요한 차이이다.

회로도에서는 두 선을 연결하는 것만으로도 AND(곱) 관계를 표현할 수 있으므로 점(·) 기호는 종종 생략한다.
수식에서 점(·)은 AND를 뜻하지만, 실제 회로에서는 AND 게이트가 필요하다. 유선 AND(wired-AND)는 오픈드레인/오픈컬렉터 등 특수 조건에서만 성립한다.
정리하면, 곱셈이 AND, 덧셈이 OR를 나타낸다고 생각하되, 불 대수의 고유한 법칙—특히 멱등, 보수, 흡수, 분배—을 활용해 식을 간단히 하라.

### De Morgan's Law

불 대수에는 여러 정리(theorem)가 있지만, 그중 핵심은 드모르간의 정리(De Morgan's Theorem)이다.
컨센서스 정리(Consensus Theorem)도 중요하지만, 지금은 드모르간 정리에 집중하자.

이제 드모르간의 법칙(De Morgan's Law)을 보자. 이 법칙의 의미는 다음과 같다.

1. OR 연산 전체를 부정하면, 각 항의 부정을 AND로 연결할 수 있다.
2. AND 연산 전체를 부정하면, 각 항의 부정을 OR로 연결할 수 있다.
즉,
$$
\overline{A + B} = \overline{A}\cdot\overline{B}, \quad
\overline{A \cdot B} = \overline{A} + \overline{B}.
$$

예를 들어, $(X\cdot Y)$에 NOT을 적용하면
NOT이 각각의 항으로 “분배”되어 $(\overline{X} + \overline{Y})$로 바뀐다.
즉, AND가 OR로 바뀌고 각 항이 부정된다.

반대로 $(X + Y)$에 NOT을 적용하면
$(\overline{X}\cdot \overline{Y})$가 된다.
즉, OR이 AND로 바뀌고 각 항이 부정된다.
이것이 드모르간 법칙의 기본 구조다.

요컨대 드모르간의 법칙은 불 논리 연산의 매우 중요한 성질이다.

예로 $F = X + \overline{X}Y$를 생각해 보자.
이 식의 단순화에는 주로 흡수/분배 가법칙이 쓰인다.
$$
F = X + \overline{X}Y
= (X + \overline{X})(X + Y)
= 1\cdot (X + Y)
= X + Y
$$

만약 위 식 (F) “전체”를 부정하려면, 드모르간을 적용하여 항별로 부정을 옮기고 AND/OR를 서로 교환하라.
일반적으로
$$
\overline{F} = \overline{X + \overline{X}Y}
= \overline{X}\cdot \overline{\overline{X}Y}
= \overline{X}\cdot (X + \overline{Y})
$$
처럼 진행한다. (여기서도 드모르간을 단계적으로 적용한다.)

따라서 원래 식이 $F=X$라면, 그 보수(Complement)는 당연히 $\overline{F}=\overline{X}$가 된다.
이처럼 보수 관계로 짝을 이루는 것을 이중(dual) 관계라 부른다.

드모르간의 법칙은 게이트 수준으로도 일반화된다.
예를 들어 NAND 게이트를 생각하면, “출력에서의 NOT”을 “입력들의 NOT + 주연산 교환(AND↔OR)”으로 옮길 수 있다고 볼 수 있다.
즉, 입력 (X, Y)에 각각 인버터(NOT)를 붙이고 그 두 출력을 OR로 묶으면 NAND의 동작과 동치가 된다.

또한 NOT은 회로 기호에서 버블(bubble)로 표현할 수 있으므로, 버블을 “출력에서 입력 쪽으로 옮기는” 해석을 통해
게이트 종류가 AND↔OR로 바뀐다(드모르간).
즉, AND의 출력 버블을 입력 쪽으로 분배하면 OR 형태로 동작하고,
OR의 출력 버블을 입력 쪽으로 분배하면 AND 형태로 동작한다.

이러한 변환은 수식으로도 요약된다.
$$
\overline{X\cdot Y}=\overline{X}+\overline{Y}, \quad
\overline{X+Y}=\overline{X}\cdot\overline{Y}.
$$
따라서 드모르간 법칙 때문에 NAND와 NOR의 기호가 서로 대칭적인 관계를 갖는다.

정리하면, 드모르간의 법칙에서 출발해 NAND와 NOR가 상호 변환 가능한 형태로 표현된다.
이 두 게이트는 드모르간 법칙의 가장 직접적인 응용 예라 할 수 있다.

### Truth Table

이제 논리 최소화(logic minimization)를 위해 진리표(truth table)를 살펴보자.
논리 회로를 구현하려면 먼저 입력 조합 중 어떤 경우에 출력이 1이 되는지를 정리하라.

예를 들어 3개의 입력 (A, B, C)에 대해 출력이 1이 되는 조합이 다음과 같다고 하자.

* $(A=0, B=1, C=1)$  $\Rightarrow \overline{A}BC$
* $(A=1, B=0, C=0)$  $\Rightarrow A\overline{B}\overline{C}$
* $(A=1, B=1, C=0)$  $\Rightarrow AB\overline{C}$
* $(A=1, B=1, C=1)$  $\Rightarrow ABC$

따라서 최종식은
$$
F=\overline{A}BC+A\overline{B}\overline{C}+AB\overline{C}+ABC
$$
가 된다.

이와 같은 방식으로 진리표를 이용해 출력이 1이 되는 항(곱항, minterm) 들을 OR로 결합하면 논리식 ($F$)를 구할 수 있다.

이제 식을 단순화할 수 있다. 예를 들어
$$
\begin{align*}
& B\overline{C} + BC, \quad
&= B(\underbrace{\overline{C} + C}_{=1}), \quad
&= B
\end{align*}
$$
이므로, 같은 형태가 보이면 (B)로 묶어 간소화하라. 위 예에서는
$$
AB\overline{C} + ABC = A B(\overline{C}+C)=AB
$$
처럼 줄어든다. 이런 과정을 반복하면 최종적으로 더 간결한 식을 얻는다. 이것이 불 대수 성질을 이용한 논리 최소화다.

이러한 항들을 AND, OR의 분배법칙으로 더 단순하게 만들 수 있다. 불필요한 항을 제거하고 공통항을 묶어 최종식을 간결하게 하라.

이번에는 NOT 연산이 포함된 식을 보자. 예를 들어 식이 $\overline{X+Y}$ 형태라면 드모르간 법칙에 따라
$$
\overline{X+Y}=\overline{X}\cdot\overline{Y}
$$
로 바뀐다. 그리고 불 대수의 성질을 이용하면
$$
XY+\overline{X}Y = Y(X+\overline{X})=Y
$$
처럼 중복 항을 제거할 수도 있다. (근거는 $X+\overline{X}=1$과 분배법칙이다.)

논리회로를 배울 때는 진리표의 의미를 정확히 이해하라. 진리표는 가능한 모든 입력 조합(input pattern)에 대해 어떤 조합에서 출력이 1이 되는지를 정리한 표다. 이 표를 통해 회로의 동작을 명확히 파악할 수 있다.

진리표를 해석할 때는 항(term) 의 개념을 구분하라. 특히

* 곱의 합(Sum of Products, SOP): 출력이 1인 모든 곱항(minterm) 을 (+)로 묶은 정규형/표준합 형태
* 합의 곱(Product of Sums, POS): 출력이 0인 모든 합항(maxterm) 을 $\cdot$로 묶은 정규형/표준곱 형태를 구분해라.

예를 들어 입력이 (D,C,B,A) 네 개일 때, 출력이 1이 되는 조합을 나열하면 다음과 같은 곱항(minterm) 들이 생긴다:
$$
\overline{D}\overline{C}B\overline{A}\quad
\overline{D}C\overline{B}A\quad
\overline{D}CBA\quad
D\overline{C}BA\quad
DC\overline{B}A
$$
이와 같이 진리표에서 1을 만드는 곱항을 식으로 표현한 것이 정규형(SOP) 이다.

주의할 점은 입력의 순서(input order) 를 일관되게 유지하라는 것이다. 항의 변수 순서를 바꾸면 같은 항 이지만, 진리표의 이진 인덱스 매핑(예: $m_i$)을 사용할 때는 ($D,C,B,A$) 순서를 기준으로 2진수를 읽어야 혼동이 없다.

이런 여러 곱항을 OR(+)로 결합한 결과가 표준형(SOP)이다. 즉,
$$
F=\overline{D}\overline{C}B\overline{A}+
\overline{D}C\overline{B}A+
\cdots
$$
처럼 쓰면 된다.

하지만 이러한 표준형은 그대로 사용하면 너무 복잡하다.
불 대수의 성질을 이용하면 불필요한 항을 제거해 더 간단한 형태로 최소화(minimize) 할 수 있다.

### Minterm의 정의

이제 또 하나의 용어, 최소항(minterm) 을 보자.
최소항이란 모든 변수$D, C, B, A$를 한 번씩 포함 하되, 각 변수가 원형 또는 보수 중 하나로 나타나는 곱항(product term) 이고, 진리표에서 정확히 한 행(입력 조합 하나) 에서만 1이 되는 항을 말한다.
예를 들어 입력이 $D, C, B, A$일 때, 각 입력 조합은 이진수로 $0\sim15$까지 번호를 매길 수 있다.
이때 출력이 1이 되는 조합의 번호가 바로 최소항 번호(minterm index) 이다.
예를 들어 출력이 1이 되는 항이 $2, 3, 5, 7, 11, 13$이라면 이를
$$
F=\Sigma m(2,3,5,7,11,13)
$$
처럼 표현한다.

이것이 바로 최소항의 정의이다.
이를 회로도로 표현하면, 각 최소항을 AND 게이트(모든 변수 포함, 일부는 보수)로 만들고, 그 모든 출력을 OR 게이트로 합친 형태가 된다.
즉 SOP(곱의 합) 정규형 구조다.

각 항의 부정(¬)은 버블(bubble)로 표현할 수 있다.
즉, 입력 신호에 버블이 붙으면 'NOT'을 의미하고, 각 항은 AND 게이트로 연결된다.
마지막에는 여러 AND 게이트의 출력을 OR 게이트로 모아 전체 출력을 만든다.

진리표의 숫자 $2,3,5,7,11,13$은 참조용 인덱스일 뿐이다.
중요한 것은 어떤 변수가 보수로 들어가는지(버블이 붙는지), 그리고 어떤 신호들이 AND 및 OR 게이트로 연결되는지이다.
(팁) 인덱스를 매길 때는 변수 순서 ($D,C,B,A$)를 고정하고, 그 순서대로 이진수를 읽어 10진수로 변환해라. 순서를 바꾸면 인덱스가 달라진다.

마지막으로, 논리 최소화(logic minimization)를 더 효과적으로 수행하려면 카르노 맵(Karnaugh Map, K-map) 개념을 알아야 한다.
이 내용은 다음 강의에서 이어서 설명하겠다.

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>